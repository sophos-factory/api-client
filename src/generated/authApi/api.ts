/* tslint:disable */
/* eslint-disable */
/**
 * Sophos Factory Auth API v1
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AppAlert
 */
export interface AppAlert {
    /**
     * 
     * @type {string}
     * @memberof AppAlert
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof AppAlert
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof AppAlert
     */
    expires?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AppAlert
     */
    deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AppAlert
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof AppAlert
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof AppAlert
     */
    ack_text?: string;
    /**
     * 
     * @type {string}
     * @memberof AppAlert
     */
    link_url?: string;
    /**
     * 
     * @type {string}
     * @memberof AppAlert
     */
    link_text?: string;
    /**
     * 
     * @type {string}
     * @memberof AppAlert
     */
    icon_name?: string;
    /**
     * 
     * @type {string}
     * @memberof AppAlert
     */
    icon_color?: string;
    /**
     * 
     * @type {AppAlertAcks}
     * @memberof AppAlert
     */
    acks?: AppAlertAcks;
}
/**
 * 
 * @export
 * @interface AppAlertAcks
 */
export interface AppAlertAcks {
    /**
     * 
     * @type {string}
     * @memberof AppAlertAcks
     */
    user_id?: string;
    /**
     * 
     * @type {string}
     * @memberof AppAlertAcks
     */
    occurred?: string;
}
/**
 * 
 * @export
 * @interface FactoryStats
 */
export interface FactoryStats {
    /**
     * 
     * @type {number}
     * @memberof FactoryStats
     */
    users?: number;
    /**
     * 
     * @type {number}
     * @memberof FactoryStats
     */
    organizations?: number;
    /**
     * 
     * @type {number}
     * @memberof FactoryStats
     */
    credits?: number;
    /**
     * 
     * @type {number}
     * @memberof FactoryStats
     */
    runnerPools?: number;
    /**
     * 
     * @type {number}
     * @memberof FactoryStats
     */
    runners?: number;
    /**
     * 
     * @type {FactoryStatsRuns}
     * @memberof FactoryStats
     */
    runs?: FactoryStatsRuns;
}
/**
 * 
 * @export
 * @interface FactoryStatsRuns
 */
export interface FactoryStatsRuns {
    /**
     * 
     * @type {number}
     * @memberof FactoryStatsRuns
     */
    total?: number;
    /**
     * 
     * @type {number}
     * @memberof FactoryStatsRuns
     */
    succeeded?: number;
    /**
     * 
     * @type {number}
     * @memberof FactoryStatsRuns
     */
    failed?: number;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    orgId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject
     */
    returnGroups?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    password: string;
}
/**
 * 
 * @export
 * @interface InlineObject10
 */
export interface InlineObject10 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject10
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface InlineObject11
 */
export interface InlineObject11 {
    /**
     * 
     * @type {Set<string>}
     * @memberof InlineObject11
     */
    group_ids?: Set<string>;
}
/**
 * 
 * @export
 * @interface InlineObject12
 */
export interface InlineObject12 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    email: string;
}
/**
 * 
 * @export
 * @interface InlineObject13
 */
export interface InlineObject13 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    password: string;
}
/**
 * 
 * @export
 * @interface InlineObject14
 */
export interface InlineObject14 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    name: string;
}
/**
 * 
 * @export
 * @interface InlineObject15
 */
export interface InlineObject15 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject15
     */
    current_password: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject15
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject15
     */
    confirm_password: string;
}
/**
 * 
 * @export
 * @interface InlineObject16
 */
export interface InlineObject16 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject16
     */
    email: string;
}
/**
 * 
 * @export
 * @interface InlineObject17
 */
export interface InlineObject17 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject17
     */
    phone_number: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject17
     */
    country_code: string;
}
/**
 * 
 * @export
 * @interface InlineObject18
 */
export interface InlineObject18 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject18
     */
    code: string;
}
/**
 * 
 * @export
 * @interface InlineObject19
 */
export interface InlineObject19 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject19
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject19
     */
    expire?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject19
     */
    expire_unit?: InlineObject19ExpireUnitEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject19ExpireUnitEnum {
    Hours = 'hours',
    Days = 'days',
    Years = 'years'
}

/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    password: string;
}
/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    code: string;
}
/**
 * 
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    uuid: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    status: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject4
     */
    authy_id: number;
}
/**
 * 
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    code: string;
}
/**
 * 
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    image_id: string;
}
/**
 * 
 * @export
 * @interface InlineObject7
 */
export interface InlineObject7 {
    /**
     * 
     * @type {object}
     * @memberof InlineObject7
     */
    capabilities?: object;
}
/**
 * 
 * @export
 * @interface InlineObject8
 */
export interface InlineObject8 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    email?: string;
    /**
     * 
     * @type {Set<string>}
     * @memberof InlineObject8
     */
    group_ids?: Set<string>;
}
/**
 * 
 * @export
 * @interface InlineObject9
 */
export interface InlineObject9 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    email?: string;
    /**
     * 
     * @type {Set<string>}
     * @memberof InlineObject9
     */
    group_ids?: Set<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Array<Organization>}
     * @memberof InlineResponse200
     */
    organizations?: Array<Organization>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Array<User>}
     * @memberof InlineResponse2001
     */
    users?: Array<User>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {Array<AppAlert>}
     * @memberof InlineResponse2002
     */
    users?: Array<AppAlert>;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {Array<UserGroup>}
     * @memberof InlineResponse2003
     */
    users?: Array<UserGroup>;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {Array<OrganizationInvite>}
     * @memberof InlineResponse2004
     */
    users?: Array<OrganizationInvite>;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {Array<Token>}
     * @memberof InlineResponse2005
     */
    tokens?: Array<Token>;
}
/**
 * 
 * @export
 * @interface NotificationChannel
 */
export interface NotificationChannel {
    /**
     * 
     * @type {string}
     * @memberof NotificationChannel
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationChannel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationChannel
     */
    type?: NotificationChannelTypeEnum;
    /**
     * 
     * @type {NotificationChannelSettings}
     * @memberof NotificationChannel
     */
    settings?: NotificationChannelSettings;
    /**
     * 
     * @type {Array<string>}
     * @memberof NotificationChannel
     */
    events?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof NotificationChannel
     */
    auth?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum NotificationChannelTypeEnum {
    Email = 'email'
}

/**
 * 
 * @export
 * @interface NotificationChannelSettings
 */
export interface NotificationChannelSettings {
    /**
     * 
     * @type {Array<string>}
     * @memberof NotificationChannelSettings
     */
    recipients?: Array<string>;
}
/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    modified?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    zip?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    contact_name?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    contact_email?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    image_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    plan?: string;
    /**
     * 
     * @type {OrganizationPlanQuotas}
     * @memberof Organization
     */
    plan_quotas?: OrganizationPlanQuotas;
    /**
     * 
     * @type {OrganizationTenant}
     * @memberof Organization
     */
    tenant?: OrganizationTenant;
    /**
     * 
     * @type {Array<NotificationChannel>}
     * @memberof Organization
     */
    notification_channels?: Array<NotificationChannel>;
}
/**
 * 
 * @export
 * @interface OrganizationInvite
 */
export interface OrganizationInvite {
    /**
     * 
     * @type {string}
     * @memberof OrganizationInvite
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationInvite
     */
    organization_id?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationInvite
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationInvite
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationInvite
     */
    expires_at?: string;
}
/**
 * 
 * @export
 * @interface OrganizationPlanQuotas
 */
export interface OrganizationPlanQuotas {
    /**
     * 
     * @type {number}
     * @memberof OrganizationPlanQuotas
     */
    project_count?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationPlanQuotas
     */
    user_count?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationPlanQuotas
     */
    agent_count?: number;
}
/**
 * 
 * @export
 * @interface OrganizationTenant
 */
export interface OrganizationTenant {
    /**
     * 
     * @type {string}
     * @memberof OrganizationTenant
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationTenant
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof Token
     */
    expire?: number;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    expire_unit?: TokenExpireUnitEnum;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    token?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TokenExpireUnitEnum {
    Hours = 'hours',
    Days = 'days',
    Weeks = 'weeks',
    Years = 'years'
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    organization_id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    user_mfa_id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    mfaEnabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    last_login?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    admin?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    blocked?: boolean;
}
/**
 * 
 * @export
 * @interface UserActivity
 */
export interface UserActivity {
    /**
     * 
     * @type {string}
     * @memberof UserActivity
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserActivity
     */
    operation_id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserActivity
     */
    occurred?: string;
}
/**
 * 
 * @export
 * @interface UserGroup
 */
export interface UserGroup {
    /**
     * 
     * @type {string}
     * @memberof UserGroup
     */
    group_id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGroup
     */
    default_project_role?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserGroup
     */
    default_project_run: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserGroup
     */
    create_projects: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserGroup
     */
    organization_admin: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserGroup
     */
    user_count?: number;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an App Alert
         * @param {AppAlert} appAlert 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAppAlert: async (appAlert: AppAlert, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appAlert' is not null or undefined
            assertParamExists('createAppAlert', 'appAlert', appAlert)
            const localVarPath = `/admin/alerts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appAlert, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an App Alert
         * @param {string} alertId Alert ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAppAlert: async (alertId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('deleteAppAlert', 'alertId', alertId)
            const localVarPath = `/admin/alerts/{alert_id}`
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete organization by UUID, for use by platform Admins
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization: async (organizationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganization', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes user from every organization
         * @summary Delete a User by UUID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all app alerts
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppAlerts: async (offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/alerts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve stats of the Factory platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFactoryStats: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization by UUID, for use by platform Admins
         * @param {string} organizationId Organization ID
         * @param {Array<'notification_channels'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationByIdAdmin: async (organizationId: string, fields?: Array<'notification_channels'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationByIdAdmin', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/admin`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all app alerts that have not been acknowledged by the session
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionAlerts: async (offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/alerts/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Acknowledges an alert
         * @param {string} alertId Alert ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionAcknowledgeAlert: async (alertId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('sessionAcknowledgeAlert', 'alertId', alertId)
            const localVarPath = `/admin/alerts/{alert_id}`
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set a user primary organization
         * @param {string} organizationId Organization ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserPrimaryOrganization: async (organizationId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('setUserPrimaryOrganization', 'organizationId', organizationId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('setUserPrimaryOrganization', 'userId', userId)
            const localVarPath = `/user/{user_id}/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update organization capabilities
         * @param {string} organizationId Organization ID
         * @param {InlineObject7} [inlineObject7] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationCapabilities: async (organizationId: string, inlineObject7?: InlineObject7, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganizationCapabilities', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/capabilities`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject7, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update organization plan
         * @param {string} organizationId Organization ID
         * @param {Organization} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationPlan: async (organizationId: string, organization: Organization, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganizationPlan', 'organizationId', organizationId)
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('updateOrganizationPlan', 'organization', organization)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user information (except password)
         * @param {string} userId User ID
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserById: async (userId: string, user: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserById', 'userId', userId)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateUserById', 'user', user)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an App Alert
         * @param {AppAlert} appAlert 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAppAlert(appAlert: AppAlert, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppAlert>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAppAlert(appAlert, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an App Alert
         * @param {string} alertId Alert ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAppAlert(alertId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppAlert>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAppAlert(alertId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete organization by UUID, for use by platform Admins
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganization(organizationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganization(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes user from every organization
         * @summary Delete a User by UUID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all app alerts
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAppAlerts(offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAppAlerts(offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve stats of the Factory platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFactoryStats(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFactoryStats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization by UUID, for use by platform Admins
         * @param {string} organizationId Organization ID
         * @param {Array<'notification_channels'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationByIdAdmin(organizationId: string, fields?: Array<'notification_channels'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationByIdAdmin(organizationId, fields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all app alerts that have not been acknowledged by the session
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionAlerts(offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionAlerts(offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Acknowledges an alert
         * @param {string} alertId Alert ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionAcknowledgeAlert(alertId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppAlert>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionAcknowledgeAlert(alertId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set a user primary organization
         * @param {string} organizationId Organization ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserPrimaryOrganization(organizationId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserPrimaryOrganization(organizationId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update organization capabilities
         * @param {string} organizationId Organization ID
         * @param {InlineObject7} [inlineObject7] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationCapabilities(organizationId: string, inlineObject7?: InlineObject7, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationCapabilities(organizationId, inlineObject7, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update organization plan
         * @param {string} organizationId Organization ID
         * @param {Organization} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationPlan(organizationId: string, organization: Organization, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationPlan(organizationId, organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user information (except password)
         * @param {string} userId User ID
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserById(userId: string, user: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserById(userId, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an App Alert
         * @param {AppAlert} appAlert 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAppAlert(appAlert: AppAlert, options?: any): AxiosPromise<AppAlert> {
            return localVarFp.createAppAlert(appAlert, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an App Alert
         * @param {string} alertId Alert ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAppAlert(alertId: string, options?: any): AxiosPromise<AppAlert> {
            return localVarFp.deleteAppAlert(alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete organization by UUID, for use by platform Admins
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganization(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes user from every organization
         * @summary Delete a User by UUID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.getAllUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all app alerts
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppAlerts(offset?: number, limit?: number, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.getAppAlerts(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve stats of the Factory platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFactoryStats(options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.getFactoryStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization by UUID, for use by platform Admins
         * @param {string} organizationId Organization ID
         * @param {Array<'notification_channels'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationByIdAdmin(organizationId: string, fields?: Array<'notification_channels'>, options?: any): AxiosPromise<Organization> {
            return localVarFp.getOrganizationByIdAdmin(organizationId, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all app alerts that have not been acknowledged by the session
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionAlerts(offset?: number, limit?: number, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.getSessionAlerts(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Acknowledges an alert
         * @param {string} alertId Alert ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionAcknowledgeAlert(alertId: string, options?: any): AxiosPromise<AppAlert> {
            return localVarFp.sessionAcknowledgeAlert(alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set a user primary organization
         * @param {string} organizationId Organization ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserPrimaryOrganization(organizationId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.setUserPrimaryOrganization(organizationId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update organization capabilities
         * @param {string} organizationId Organization ID
         * @param {InlineObject7} [inlineObject7] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationCapabilities(organizationId: string, inlineObject7?: InlineObject7, options?: any): AxiosPromise<void> {
            return localVarFp.updateOrganizationCapabilities(organizationId, inlineObject7, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update organization plan
         * @param {string} organizationId Organization ID
         * @param {Organization} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationPlan(organizationId: string, organization: Organization, options?: any): AxiosPromise<Organization> {
            return localVarFp.updateOrganizationPlan(organizationId, organization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user information (except password)
         * @param {string} userId User ID
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserById(userId: string, user: User, options?: any): AxiosPromise<User> {
            return localVarFp.updateUserById(userId, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * 
     * @summary Create an App Alert
     * @param {AppAlert} appAlert 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createAppAlert(appAlert: AppAlert, options?: any) {
        return AdminApiFp(this.configuration).createAppAlert(appAlert, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an App Alert
     * @param {string} alertId Alert ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteAppAlert(alertId: string, options?: any) {
        return AdminApiFp(this.configuration).deleteAppAlert(alertId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete organization by UUID, for use by platform Admins
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteOrganization(organizationId: string, options?: any) {
        return AdminApiFp(this.configuration).deleteOrganization(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes user from every organization
     * @summary Delete a User by UUID
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteUser(userId: string, options?: any) {
        return AdminApiFp(this.configuration).deleteUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getAllUsers(options?: any) {
        return AdminApiFp(this.configuration).getAllUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all app alerts
     * @param {number} [offset] Offset
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getAppAlerts(offset?: number, limit?: number, options?: any) {
        return AdminApiFp(this.configuration).getAppAlerts(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve stats of the Factory platform
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getFactoryStats(options?: any) {
        return AdminApiFp(this.configuration).getFactoryStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization by UUID, for use by platform Admins
     * @param {string} organizationId Organization ID
     * @param {Array<'notification_channels'>} [fields] Additional fields to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getOrganizationByIdAdmin(organizationId: string, fields?: Array<'notification_channels'>, options?: any) {
        return AdminApiFp(this.configuration).getOrganizationByIdAdmin(organizationId, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all app alerts that have not been acknowledged by the session
     * @param {number} [offset] Offset
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getSessionAlerts(offset?: number, limit?: number, options?: any) {
        return AdminApiFp(this.configuration).getSessionAlerts(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Acknowledges an alert
     * @param {string} alertId Alert ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public sessionAcknowledgeAlert(alertId: string, options?: any) {
        return AdminApiFp(this.configuration).sessionAcknowledgeAlert(alertId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set a user primary organization
     * @param {string} organizationId Organization ID
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public setUserPrimaryOrganization(organizationId: string, userId: string, options?: any) {
        return AdminApiFp(this.configuration).setUserPrimaryOrganization(organizationId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update organization capabilities
     * @param {string} organizationId Organization ID
     * @param {InlineObject7} [inlineObject7] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateOrganizationCapabilities(organizationId: string, inlineObject7?: InlineObject7, options?: any) {
        return AdminApiFp(this.configuration).updateOrganizationCapabilities(organizationId, inlineObject7, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update organization plan
     * @param {string} organizationId Organization ID
     * @param {Organization} organization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateOrganizationPlan(organizationId: string, organization: Organization, options?: any) {
        return AdminApiFp(this.configuration).updateOrganizationPlan(organizationId, organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user information (except password)
     * @param {string} userId User ID
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateUserById(userId: string, user: User, options?: any) {
        return AdminApiFp(this.configuration).updateUserById(userId, user, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generates session by authenticating user by password
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (inlineObject2: InlineObject2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject2' is not null or undefined
            assertParamExists('login', 'inlineObject2', inlineObject2)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary MFA callback endpoint used by Authy
         * @param {InlineObject4} inlineObject4 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginMfaCallback: async (inlineObject4: InlineObject4, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject4' is not null or undefined
            assertParamExists('loginMfaCallback', 'inlineObject4', inlineObject4)
            const localVarPath = `/auth/login/mfa/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject4, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Complete MFA login flow
         * @param {string} token MFA Token
         * @param {InlineObject3} inlineObject3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginMfaComplete: async (token: string, inlineObject3: InlineObject3, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('loginMfaComplete', 'token', token)
            // verify required parameter 'inlineObject3' is not null or undefined
            assertParamExists('loginMfaComplete', 'inlineObject3', inlineObject3)
            const localVarPath = `/auth/login/mfa`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject3, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Polled by client during MFA flow
         * @param {string} token MFA Token
         * @param {InlineObject5} inlineObject5 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginMfaStatus: async (token: string, inlineObject5: InlineObject5, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('loginMfaStatus', 'token', token)
            // verify required parameter 'inlineObject5' is not null or undefined
            assertParamExists('loginMfaStatus', 'inlineObject5', inlineObject5)
            const localVarPath = `/v1/auth/login/mfa/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject5, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Destroys session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Renew session with an existing session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renew: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/renew`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Registration
         * @param {string} token Reset token
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup: async (token: string, inlineObject1: InlineObject1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('signup', 'token', token)
            // verify required parameter 'inlineObject1' is not null or undefined
            assertParamExists('signup', 'inlineObject1', inlineObject1)
            const localVarPath = `/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate a session is valid, and returns back context
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateSession: async (inlineObject?: InlineObject, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Generates session by authenticating user by password
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(inlineObject2: InlineObject2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(inlineObject2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary MFA callback endpoint used by Authy
         * @param {InlineObject4} inlineObject4 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginMfaCallback(inlineObject4: InlineObject4, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginMfaCallback(inlineObject4, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Complete MFA login flow
         * @param {string} token MFA Token
         * @param {InlineObject3} inlineObject3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginMfaComplete(token: string, inlineObject3: InlineObject3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginMfaComplete(token, inlineObject3, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Polled by client during MFA flow
         * @param {string} token MFA Token
         * @param {InlineObject5} inlineObject5 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginMfaStatus(token: string, inlineObject5: InlineObject5, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginMfaStatus(token, inlineObject5, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Destroys session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Renew session with an existing session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renew(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renew(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary User Registration
         * @param {string} token Reset token
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signup(token: string, inlineObject1: InlineObject1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signup(token, inlineObject1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Validate a session is valid, and returns back context
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateSession(inlineObject?: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateSession(inlineObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Generates session by authenticating user by password
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(inlineObject2: InlineObject2, options?: any): AxiosPromise<void> {
            return localVarFp.login(inlineObject2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary MFA callback endpoint used by Authy
         * @param {InlineObject4} inlineObject4 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginMfaCallback(inlineObject4: InlineObject4, options?: any): AxiosPromise<void> {
            return localVarFp.loginMfaCallback(inlineObject4, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Complete MFA login flow
         * @param {string} token MFA Token
         * @param {InlineObject3} inlineObject3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginMfaComplete(token: string, inlineObject3: InlineObject3, options?: any): AxiosPromise<void> {
            return localVarFp.loginMfaComplete(token, inlineObject3, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Polled by client during MFA flow
         * @param {string} token MFA Token
         * @param {InlineObject5} inlineObject5 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginMfaStatus(token: string, inlineObject5: InlineObject5, options?: any): AxiosPromise<void> {
            return localVarFp.loginMfaStatus(token, inlineObject5, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Destroys session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<void> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Renew session with an existing session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renew(options?: any): AxiosPromise<void> {
            return localVarFp.renew(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User Registration
         * @param {string} token Reset token
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(token: string, inlineObject1: InlineObject1, options?: any): AxiosPromise<void> {
            return localVarFp.signup(token, inlineObject1, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate a session is valid, and returns back context
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateSession(inlineObject?: InlineObject, options?: any): AxiosPromise<void> {
            return localVarFp.validateSession(inlineObject, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Generates session by authenticating user by password
     * @param {InlineObject2} inlineObject2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(inlineObject2: InlineObject2, options?: any) {
        return AuthApiFp(this.configuration).login(inlineObject2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary MFA callback endpoint used by Authy
     * @param {InlineObject4} inlineObject4 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public loginMfaCallback(inlineObject4: InlineObject4, options?: any) {
        return AuthApiFp(this.configuration).loginMfaCallback(inlineObject4, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Complete MFA login flow
     * @param {string} token MFA Token
     * @param {InlineObject3} inlineObject3 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public loginMfaComplete(token: string, inlineObject3: InlineObject3, options?: any) {
        return AuthApiFp(this.configuration).loginMfaComplete(token, inlineObject3, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Polled by client during MFA flow
     * @param {string} token MFA Token
     * @param {InlineObject5} inlineObject5 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public loginMfaStatus(token: string, inlineObject5: InlineObject5, options?: any) {
        return AuthApiFp(this.configuration).loginMfaStatus(token, inlineObject5, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Destroys session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logout(options?: any) {
        return AuthApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Renew session with an existing session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public renew(options?: any) {
        return AuthApiFp(this.configuration).renew(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary User Registration
     * @param {string} token Reset token
     * @param {InlineObject1} inlineObject1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public signup(token: string, inlineObject1: InlineObject1, options?: any) {
        return AuthApiFp(this.configuration).signup(token, inlineObject1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate a session is valid, and returns back context
     * @param {InlineObject} [inlineObject] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public validateSession(inlineObject?: InlineObject, options?: any) {
        return AuthApiFp(this.configuration).validateSession(inlineObject, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns Status of the Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a response if the service is active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns Status of the Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a response if the service is active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Returns Status of the Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet(options?: any): AxiosPromise<void> {
            return localVarFp.healthGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a response if the service is active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: any): AxiosPromise<void> {
            return localVarFp.rootGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Returns Status of the Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public healthGet(options?: any) {
        return DefaultApiFp(this.configuration).healthGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a response if the service is active
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rootGet(options?: any) {
        return DefaultApiFp(this.configuration).rootGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImageApi - axios parameter creator
 * @export
 */
export const ImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete organization image
         * @param {string} organizationId Organization ID
         * @param {string} imageId Image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationImage: async (organizationId: string, imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganizationImage', 'organizationId', organizationId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('deleteOrganizationImage', 'imageId', imageId)
            const localVarPath = `/organizations/{organization_id}/images/{image_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete organization image
         * @param {string} organizationId Organization ID
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationProjectImage: async (organizationId: string, projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganizationProjectImage', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteOrganizationProjectImage', 'projectId', projectId)
            const localVarPath = `/organizations/{organization_id}/images/projects/{project_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project images
         * @param {string} organizationId Organization ID
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectImage: async (organizationId: string, projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getProjectImage', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectImage', 'projectId', projectId)
            const localVarPath = `/organizations/{organization_id}/projects/{project_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set organization image
         * @param {string} organizationId Organization ID
         * @param {InlineObject6} inlineObject6 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrganizationImage: async (organizationId: string, inlineObject6: InlineObject6, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('setOrganizationImage', 'organizationId', organizationId)
            // verify required parameter 'inlineObject6' is not null or undefined
            assertParamExists('setOrganizationImage', 'inlineObject6', inlineObject6)
            const localVarPath = `/organizations/{organization_id}/images/set`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject6, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set organization image
         * @param {string} organizationId Organization ID
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadOrganizationImage: async (organizationId: string, body: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('uploadOrganizationImage', 'organizationId', organizationId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadOrganizationImage', 'body', body)
            const localVarPath = `/organizations/{organization_id}/images`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'image/png';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload project image
         * @param {string} organizationId Organization ID
         * @param {string} projectId Project ID
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProjectImage: async (organizationId: string, projectId: string, body: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('uploadProjectImage', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('uploadProjectImage', 'projectId', projectId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadProjectImage', 'body', body)
            const localVarPath = `/organizations/{organization_id}/projects/{project_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'image/png';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageApi - functional programming interface
 * @export
 */
export const ImageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete organization image
         * @param {string} organizationId Organization ID
         * @param {string} imageId Image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationImage(organizationId: string, imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationImage(organizationId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete organization image
         * @param {string} organizationId Organization ID
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationProjectImage(organizationId: string, projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationProjectImage(organizationId, projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get project images
         * @param {string} organizationId Organization ID
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectImage(organizationId: string, projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectImage(organizationId, projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set organization image
         * @param {string} organizationId Organization ID
         * @param {InlineObject6} inlineObject6 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setOrganizationImage(organizationId: string, inlineObject6: InlineObject6, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setOrganizationImage(organizationId, inlineObject6, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set organization image
         * @param {string} organizationId Organization ID
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadOrganizationImage(organizationId: string, body: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadOrganizationImage(organizationId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload project image
         * @param {string} organizationId Organization ID
         * @param {string} projectId Project ID
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadProjectImage(organizationId: string, projectId: string, body: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadProjectImage(organizationId, projectId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImageApi - factory interface
 * @export
 */
export const ImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImageApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete organization image
         * @param {string} organizationId Organization ID
         * @param {string} imageId Image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationImage(organizationId: string, imageId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationImage(organizationId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete organization image
         * @param {string} organizationId Organization ID
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationProjectImage(organizationId: string, projectId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationProjectImage(organizationId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get project images
         * @param {string} organizationId Organization ID
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectImage(organizationId: string, projectId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getProjectImage(organizationId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set organization image
         * @param {string} organizationId Organization ID
         * @param {InlineObject6} inlineObject6 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrganizationImage(organizationId: string, inlineObject6: InlineObject6, options?: any): AxiosPromise<void> {
            return localVarFp.setOrganizationImage(organizationId, inlineObject6, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set organization image
         * @param {string} organizationId Organization ID
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadOrganizationImage(organizationId: string, body: any, options?: any): AxiosPromise<void> {
            return localVarFp.uploadOrganizationImage(organizationId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload project image
         * @param {string} organizationId Organization ID
         * @param {string} projectId Project ID
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProjectImage(organizationId: string, projectId: string, body: any, options?: any): AxiosPromise<void> {
            return localVarFp.uploadProjectImage(organizationId, projectId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImageApi - object-oriented interface
 * @export
 * @class ImageApi
 * @extends {BaseAPI}
 */
export class ImageApi extends BaseAPI {
    /**
     * 
     * @summary Delete organization image
     * @param {string} organizationId Organization ID
     * @param {string} imageId Image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public deleteOrganizationImage(organizationId: string, imageId: string, options?: any) {
        return ImageApiFp(this.configuration).deleteOrganizationImage(organizationId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete organization image
     * @param {string} organizationId Organization ID
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public deleteOrganizationProjectImage(organizationId: string, projectId: string, options?: any) {
        return ImageApiFp(this.configuration).deleteOrganizationProjectImage(organizationId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get project images
     * @param {string} organizationId Organization ID
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getProjectImage(organizationId: string, projectId: string, options?: any) {
        return ImageApiFp(this.configuration).getProjectImage(organizationId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set organization image
     * @param {string} organizationId Organization ID
     * @param {InlineObject6} inlineObject6 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public setOrganizationImage(organizationId: string, inlineObject6: InlineObject6, options?: any) {
        return ImageApiFp(this.configuration).setOrganizationImage(organizationId, inlineObject6, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set organization image
     * @param {string} organizationId Organization ID
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public uploadOrganizationImage(organizationId: string, body: any, options?: any) {
        return ImageApiFp(this.configuration).uploadOrganizationImage(organizationId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload project image
     * @param {string} organizationId Organization ID
     * @param {string} projectId Project ID
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public uploadProjectImage(organizationId: string, projectId: string, body: any, options?: any) {
        return ImageApiFp(this.configuration).uploadProjectImage(organizationId, projectId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InvitesApi - axios parameter creator
 * @export
 */
export const InvitesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Consume Invite
         * @param {string} token Invite token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumeInvite: async (token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('consumeInvite', 'token', token)
            const localVarPath = `/organizations/invites/consume`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete organization invite
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvite: async (organizationId: string, inviteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteInvite', 'organizationId', organizationId)
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('deleteInvite', 'inviteId', inviteId)
            const localVarPath = `/organizations/{organization_id}/invites/{invite_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"invite_id"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization invites
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvites: async (organizationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getInvites', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/invites`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resend organization invite
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendInvite: async (organizationId: string, inviteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('resendInvite', 'organizationId', organizationId)
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('resendInvite', 'inviteId', inviteId)
            const localVarPath = `/organizations/{organization_id}/invites/{invite_id}/resend`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"invite_id"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvitesApi - functional programming interface
 * @export
 */
export const InvitesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvitesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Consume Invite
         * @param {string} token Invite token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumeInvite(token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumeInvite(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete organization invite
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvite(organizationId: string, inviteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvite(organizationId, inviteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List organization invites
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvites(organizationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvites(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Resend organization invite
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendInvite(organizationId: string, inviteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendInvite(organizationId, inviteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvitesApi - factory interface
 * @export
 */
export const InvitesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvitesApiFp(configuration)
    return {
        /**
         * 
         * @summary Consume Invite
         * @param {string} token Invite token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumeInvite(token: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.consumeInvite(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete organization invite
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvite(organizationId: string, inviteId: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.deleteInvite(organizationId, inviteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization invites
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvites(organizationId: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.getInvites(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resend organization invite
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendInvite(organizationId: string, inviteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.resendInvite(organizationId, inviteId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvitesApi - object-oriented interface
 * @export
 * @class InvitesApi
 * @extends {BaseAPI}
 */
export class InvitesApi extends BaseAPI {
    /**
     * 
     * @summary Consume Invite
     * @param {string} token Invite token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitesApi
     */
    public consumeInvite(token: string, options?: any) {
        return InvitesApiFp(this.configuration).consumeInvite(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete organization invite
     * @param {string} organizationId Organization ID
     * @param {string} inviteId Invite ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitesApi
     */
    public deleteInvite(organizationId: string, inviteId: string, options?: any) {
        return InvitesApiFp(this.configuration).deleteInvite(organizationId, inviteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization invites
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitesApi
     */
    public getInvites(organizationId: string, options?: any) {
        return InvitesApiFp(this.configuration).getInvites(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resend organization invite
     * @param {string} organizationId Organization ID
     * @param {string} inviteId Invite ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitesApi
     */
    public resendInvite(organizationId: string, inviteId: string, options?: any) {
        return InvitesApiFp(this.configuration).resendInvite(organizationId, inviteId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
export const OrganizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add organization notification channel
         * @param {string} organizationId Organization ID
         * @param {NotificationChannel} notificationChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationNotificationChannel: async (organizationId: string, notificationChannel: NotificationChannel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrganizationNotificationChannel', 'organizationId', organizationId)
            // verify required parameter 'notificationChannel' is not null or undefined
            assertParamExists('addOrganizationNotificationChannel', 'notificationChannel', notificationChannel)
            const localVarPath = `/organizations/{organization_id}/notification_channels`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationChannel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Consume Invite
         * @param {string} token Invite token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumeInvite: async (token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('consumeInvite', 'token', token)
            const localVarPath = `/organizations/invites/consume`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary API to add a new Organization
         * @param {Organization} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization: async (organization: Organization, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('createOrganization', 'organization', organization)
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete organization invite
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvite: async (organizationId: string, inviteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteInvite', 'organizationId', organizationId)
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('deleteInvite', 'inviteId', inviteId)
            const localVarPath = `/organizations/{organization_id}/invites/{invite_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"invite_id"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete organization by UUID, for use by platform Admins
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization: async (organizationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganization', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization invites
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvites: async (organizationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getInvites', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/invites`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization by UUID
         * @param {string} organizationId Organization ID
         * @param {Array<'notification_channels'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationById: async (organizationId: string, fields?: Array<'notification_channels'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationById', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization by UUID, for use by platform Admins
         * @param {string} organizationId Organization ID
         * @param {Array<'notification_channels'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationByIdAdmin: async (organizationId: string, fields?: Array<'notification_channels'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationByIdAdmin', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/admin`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Admin API to list All Organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizations: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary API to list All Public Organizations. Returns only basic meta-data about each organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationsPublic: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations/all/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve public-facing information of an organization
         * @param {string} organizationId Organization ID
         * @param {Array<'notification_channels'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicOrganizationById: async (organizationId: string, fields?: Array<'notification_channels'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getPublicOrganizationById', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/public`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary API to list All Public Organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicOrganizationsById: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations/all/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all organizations that belong to the current session user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionOrganizations: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List User Organizations
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserOrganizations: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserOrganizations', 'userId', userId)
            const localVarPath = `/user/{user_id}/organizations`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove organization notification channel
         * @param {string} organizationId Organization ID
         * @param {string} notificationChannelId Notification Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrganizationNotificationChannel: async (organizationId: string, notificationChannelId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeOrganizationNotificationChannel', 'organizationId', organizationId)
            // verify required parameter 'notificationChannelId' is not null or undefined
            assertParamExists('removeOrganizationNotificationChannel', 'notificationChannelId', notificationChannelId)
            const localVarPath = `/organizations/{organization_id}/notification_channels/{notification_channel_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"notification_channel_id"}}`, encodeURIComponent(String(notificationChannelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resend organization invite
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendInvite: async (organizationId: string, inviteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('resendInvite', 'organizationId', organizationId)
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('resendInvite', 'inviteId', inviteId)
            const localVarPath = `/organizations/{organization_id}/invites/{invite_id}/resend`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"invite_id"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update organization
         * @param {string} organizationId Organization ID
         * @param {Organization} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrganizationPublic: async (organizationId: string, organization: Organization, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('setOrganizationPublic', 'organizationId', organizationId)
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('setOrganizationPublic', 'organization', organization)
            const localVarPath = `/organizations/{organization_id}/public`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update organization capabilities
         * @param {string} organizationId Organization ID
         * @param {InlineObject7} [inlineObject7] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationCapabilities: async (organizationId: string, inlineObject7?: InlineObject7, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganizationCapabilities', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/capabilities`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject7, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update organization notification channel
         * @param {string} organizationId Organization ID
         * @param {string} notificationChannelId Notification Channel ID
         * @param {NotificationChannel} notificationChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationNotificationChannel: async (organizationId: string, notificationChannelId: string, notificationChannel: NotificationChannel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganizationNotificationChannel', 'organizationId', organizationId)
            // verify required parameter 'notificationChannelId' is not null or undefined
            assertParamExists('updateOrganizationNotificationChannel', 'notificationChannelId', notificationChannelId)
            // verify required parameter 'notificationChannel' is not null or undefined
            assertParamExists('updateOrganizationNotificationChannel', 'notificationChannel', notificationChannel)
            const localVarPath = `/organizations/{organization_id}/notification_channels/{notification_channel_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"notification_channel_id"}}`, encodeURIComponent(String(notificationChannelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationChannel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update organization plan
         * @param {string} organizationId Organization ID
         * @param {Organization} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationPlan: async (organizationId: string, organization: Organization, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganizationPlan', 'organizationId', organizationId)
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('updateOrganizationPlan', 'organization', organization)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add organization notification channel
         * @param {string} organizationId Organization ID
         * @param {NotificationChannel} notificationChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrganizationNotificationChannel(organizationId: string, notificationChannel: NotificationChannel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrganizationNotificationChannel(organizationId, notificationChannel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Consume Invite
         * @param {string} token Invite token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumeInvite(token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumeInvite(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary API to add a new Organization
         * @param {Organization} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganization(organization: Organization, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganization(organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete organization invite
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvite(organizationId: string, inviteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvite(organizationId, inviteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete organization by UUID, for use by platform Admins
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganization(organizationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganization(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List organization invites
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvites(organizationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvites(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization by UUID
         * @param {string} organizationId Organization ID
         * @param {Array<'notification_channels'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationById(organizationId: string, fields?: Array<'notification_channels'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationById(organizationId, fields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization by UUID, for use by platform Admins
         * @param {string} organizationId Organization ID
         * @param {Array<'notification_channels'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationByIdAdmin(organizationId: string, fields?: Array<'notification_channels'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationByIdAdmin(organizationId, fields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Admin API to list All Organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizations(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary API to list All Public Organizations. Returns only basic meta-data about each organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationsPublic(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationsPublic(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve public-facing information of an organization
         * @param {string} organizationId Organization ID
         * @param {Array<'notification_channels'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicOrganizationById(organizationId: string, fields?: Array<'notification_channels'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicOrganizationById(organizationId, fields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary API to list All Public Organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicOrganizationsById(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicOrganizationsById(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all organizations that belong to the current session user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionOrganizations(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionOrganizations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List User Organizations
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserOrganizations(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserOrganizations(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove organization notification channel
         * @param {string} organizationId Organization ID
         * @param {string} notificationChannelId Notification Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOrganizationNotificationChannel(organizationId: string, notificationChannelId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeOrganizationNotificationChannel(organizationId, notificationChannelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Resend organization invite
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendInvite(organizationId: string, inviteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendInvite(organizationId, inviteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update organization
         * @param {string} organizationId Organization ID
         * @param {Organization} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setOrganizationPublic(organizationId: string, organization: Organization, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setOrganizationPublic(organizationId, organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update organization capabilities
         * @param {string} organizationId Organization ID
         * @param {InlineObject7} [inlineObject7] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationCapabilities(organizationId: string, inlineObject7?: InlineObject7, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationCapabilities(organizationId, inlineObject7, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update organization notification channel
         * @param {string} organizationId Organization ID
         * @param {string} notificationChannelId Notification Channel ID
         * @param {NotificationChannel} notificationChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationNotificationChannel(organizationId: string, notificationChannelId: string, notificationChannel: NotificationChannel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationNotificationChannel(organizationId, notificationChannelId, notificationChannel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update organization plan
         * @param {string} organizationId Organization ID
         * @param {Organization} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationPlan(organizationId: string, organization: Organization, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationPlan(organizationId, organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add organization notification channel
         * @param {string} organizationId Organization ID
         * @param {NotificationChannel} notificationChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationNotificationChannel(organizationId: string, notificationChannel: NotificationChannel, options?: any): AxiosPromise<void> {
            return localVarFp.addOrganizationNotificationChannel(organizationId, notificationChannel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Consume Invite
         * @param {string} token Invite token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumeInvite(token: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.consumeInvite(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary API to add a new Organization
         * @param {Organization} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(organization: Organization, options?: any): AxiosPromise<Organization> {
            return localVarFp.createOrganization(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete organization invite
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvite(organizationId: string, inviteId: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.deleteInvite(organizationId, inviteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete organization by UUID, for use by platform Admins
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganization(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization invites
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvites(organizationId: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.getInvites(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization by UUID
         * @param {string} organizationId Organization ID
         * @param {Array<'notification_channels'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationById(organizationId: string, fields?: Array<'notification_channels'>, options?: any): AxiosPromise<Organization> {
            return localVarFp.getOrganizationById(organizationId, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization by UUID, for use by platform Admins
         * @param {string} organizationId Organization ID
         * @param {Array<'notification_channels'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationByIdAdmin(organizationId: string, fields?: Array<'notification_channels'>, options?: any): AxiosPromise<Organization> {
            return localVarFp.getOrganizationByIdAdmin(organizationId, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Admin API to list All Organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizations(options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.getOrganizations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary API to list All Public Organizations. Returns only basic meta-data about each organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationsPublic(options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.getOrganizationsPublic(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve public-facing information of an organization
         * @param {string} organizationId Organization ID
         * @param {Array<'notification_channels'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicOrganizationById(organizationId: string, fields?: Array<'notification_channels'>, options?: any): AxiosPromise<Organization> {
            return localVarFp.getPublicOrganizationById(organizationId, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary API to list All Public Organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicOrganizationsById(options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.getPublicOrganizationsById(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all organizations that belong to the current session user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionOrganizations(options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.getSessionOrganizations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List User Organizations
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserOrganizations(userId: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.getUserOrganizations(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove organization notification channel
         * @param {string} organizationId Organization ID
         * @param {string} notificationChannelId Notification Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrganizationNotificationChannel(organizationId: string, notificationChannelId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeOrganizationNotificationChannel(organizationId, notificationChannelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resend organization invite
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendInvite(organizationId: string, inviteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.resendInvite(organizationId, inviteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update organization
         * @param {string} organizationId Organization ID
         * @param {Organization} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrganizationPublic(organizationId: string, organization: Organization, options?: any): AxiosPromise<Organization> {
            return localVarFp.setOrganizationPublic(organizationId, organization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update organization capabilities
         * @param {string} organizationId Organization ID
         * @param {InlineObject7} [inlineObject7] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationCapabilities(organizationId: string, inlineObject7?: InlineObject7, options?: any): AxiosPromise<void> {
            return localVarFp.updateOrganizationCapabilities(organizationId, inlineObject7, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update organization notification channel
         * @param {string} organizationId Organization ID
         * @param {string} notificationChannelId Notification Channel ID
         * @param {NotificationChannel} notificationChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationNotificationChannel(organizationId: string, notificationChannelId: string, notificationChannel: NotificationChannel, options?: any): AxiosPromise<void> {
            return localVarFp.updateOrganizationNotificationChannel(organizationId, notificationChannelId, notificationChannel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update organization plan
         * @param {string} organizationId Organization ID
         * @param {Organization} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationPlan(organizationId: string, organization: Organization, options?: any): AxiosPromise<Organization> {
            return localVarFp.updateOrganizationPlan(organizationId, organization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * 
     * @summary Add organization notification channel
     * @param {string} organizationId Organization ID
     * @param {NotificationChannel} notificationChannel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public addOrganizationNotificationChannel(organizationId: string, notificationChannel: NotificationChannel, options?: any) {
        return OrganizationsApiFp(this.configuration).addOrganizationNotificationChannel(organizationId, notificationChannel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Consume Invite
     * @param {string} token Invite token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public consumeInvite(token: string, options?: any) {
        return OrganizationsApiFp(this.configuration).consumeInvite(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary API to add a new Organization
     * @param {Organization} organization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public createOrganization(organization: Organization, options?: any) {
        return OrganizationsApiFp(this.configuration).createOrganization(organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete organization invite
     * @param {string} organizationId Organization ID
     * @param {string} inviteId Invite ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteInvite(organizationId: string, inviteId: string, options?: any) {
        return OrganizationsApiFp(this.configuration).deleteInvite(organizationId, inviteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete organization by UUID, for use by platform Admins
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrganization(organizationId: string, options?: any) {
        return OrganizationsApiFp(this.configuration).deleteOrganization(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization invites
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getInvites(organizationId: string, options?: any) {
        return OrganizationsApiFp(this.configuration).getInvites(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization by UUID
     * @param {string} organizationId Organization ID
     * @param {Array<'notification_channels'>} [fields] Additional fields to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationById(organizationId: string, fields?: Array<'notification_channels'>, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationById(organizationId, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization by UUID, for use by platform Admins
     * @param {string} organizationId Organization ID
     * @param {Array<'notification_channels'>} [fields] Additional fields to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationByIdAdmin(organizationId: string, fields?: Array<'notification_channels'>, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationByIdAdmin(organizationId, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Admin API to list All Organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizations(options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary API to list All Public Organizations. Returns only basic meta-data about each organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationsPublic(options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationsPublic(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve public-facing information of an organization
     * @param {string} organizationId Organization ID
     * @param {Array<'notification_channels'>} [fields] Additional fields to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getPublicOrganizationById(organizationId: string, fields?: Array<'notification_channels'>, options?: any) {
        return OrganizationsApiFp(this.configuration).getPublicOrganizationById(organizationId, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary API to list All Public Organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getPublicOrganizationsById(options?: any) {
        return OrganizationsApiFp(this.configuration).getPublicOrganizationsById(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all organizations that belong to the current session user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getSessionOrganizations(options?: any) {
        return OrganizationsApiFp(this.configuration).getSessionOrganizations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List User Organizations
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getUserOrganizations(userId: string, options?: any) {
        return OrganizationsApiFp(this.configuration).getUserOrganizations(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove organization notification channel
     * @param {string} organizationId Organization ID
     * @param {string} notificationChannelId Notification Channel ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public removeOrganizationNotificationChannel(organizationId: string, notificationChannelId: string, options?: any) {
        return OrganizationsApiFp(this.configuration).removeOrganizationNotificationChannel(organizationId, notificationChannelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resend organization invite
     * @param {string} organizationId Organization ID
     * @param {string} inviteId Invite ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public resendInvite(organizationId: string, inviteId: string, options?: any) {
        return OrganizationsApiFp(this.configuration).resendInvite(organizationId, inviteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update organization
     * @param {string} organizationId Organization ID
     * @param {Organization} organization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public setOrganizationPublic(organizationId: string, organization: Organization, options?: any) {
        return OrganizationsApiFp(this.configuration).setOrganizationPublic(organizationId, organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update organization capabilities
     * @param {string} organizationId Organization ID
     * @param {InlineObject7} [inlineObject7] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public updateOrganizationCapabilities(organizationId: string, inlineObject7?: InlineObject7, options?: any) {
        return OrganizationsApiFp(this.configuration).updateOrganizationCapabilities(organizationId, inlineObject7, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update organization notification channel
     * @param {string} organizationId Organization ID
     * @param {string} notificationChannelId Notification Channel ID
     * @param {NotificationChannel} notificationChannel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public updateOrganizationNotificationChannel(organizationId: string, notificationChannelId: string, notificationChannel: NotificationChannel, options?: any) {
        return OrganizationsApiFp(this.configuration).updateOrganizationNotificationChannel(organizationId, notificationChannelId, notificationChannel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update organization plan
     * @param {string} organizationId Organization ID
     * @param {Organization} organization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public updateOrganizationPlan(organizationId: string, organization: Organization, options?: any) {
        return OrganizationsApiFp(this.configuration).updateOrganizationPlan(organizationId, organization, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TokensApi - axios parameter creator
 * @export
 */
export const TokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create authorization token
         * @param {string} userId User ID
         * @param {InlineObject19} inlineObject19 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createToken: async (userId: string, inlineObject19: InlineObject19, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createToken', 'userId', userId)
            // verify required parameter 'inlineObject19' is not null or undefined
            assertParamExists('createToken', 'inlineObject19', inlineObject19)
            const localVarPath = `/user/{user_id}/tokens`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject19, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete token
         * @param {string} userId User ID
         * @param {string} tokenId Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken: async (userId: string, tokenId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteToken', 'userId', userId)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('deleteToken', 'tokenId', tokenId)
            const localVarPath = `/user/{user_id}/tokens/{token_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List authorization tokens
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTokens: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listTokens', 'userId', userId)
            const localVarPath = `/user/{user_id}/tokens`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokensApi - functional programming interface
 * @export
 */
export const TokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokensApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create authorization token
         * @param {string} userId User ID
         * @param {InlineObject19} inlineObject19 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createToken(userId: string, inlineObject19: InlineObject19, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createToken(userId, inlineObject19, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete token
         * @param {string} userId User ID
         * @param {string} tokenId Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteToken(userId: string, tokenId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteToken(userId, tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List authorization tokens
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTokens(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTokens(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TokensApi - factory interface
 * @export
 */
export const TokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokensApiFp(configuration)
    return {
        /**
         * 
         * @summary Create authorization token
         * @param {string} userId User ID
         * @param {InlineObject19} inlineObject19 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createToken(userId: string, inlineObject19: InlineObject19, options?: any): AxiosPromise<Token> {
            return localVarFp.createToken(userId, inlineObject19, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete token
         * @param {string} userId User ID
         * @param {string} tokenId Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken(userId: string, tokenId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteToken(userId, tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List authorization tokens
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTokens(userId: string, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.listTokens(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
export class TokensApi extends BaseAPI {
    /**
     * 
     * @summary Create authorization token
     * @param {string} userId User ID
     * @param {InlineObject19} inlineObject19 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public createToken(userId: string, inlineObject19: InlineObject19, options?: any) {
        return TokensApiFp(this.configuration).createToken(userId, inlineObject19, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete token
     * @param {string} userId User ID
     * @param {string} tokenId Token ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public deleteToken(userId: string, tokenId: string, options?: any) {
        return TokensApiFp(this.configuration).deleteToken(userId, tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List authorization tokens
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public listTokens(userId: string, options?: any) {
        return TokensApiFp(this.configuration).listTokens(userId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Initalizes user MFA configuration workflow
         * @param {string} userId User ID
         * @param {InlineObject17} inlineObject17 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureMfa: async (userId: string, inlineObject17: InlineObject17, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('configureMfa', 'userId', userId)
            // verify required parameter 'inlineObject17' is not null or undefined
            assertParamExists('configureMfa', 'inlineObject17', inlineObject17)
            const localVarPath = `/user/{user_id}/mfa`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject17, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create authorization token
         * @param {string} userId User ID
         * @param {InlineObject19} inlineObject19 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createToken: async (userId: string, inlineObject19: InlineObject19, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createToken', 'userId', userId)
            // verify required parameter 'inlineObject19' is not null or undefined
            assertParamExists('createToken', 'inlineObject19', inlineObject19)
            const localVarPath = `/user/{user_id}/tokens`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject19, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes user MFA configuration workflow
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMfa: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteMfa', 'userId', userId)
            const localVarPath = `/user/{user_id}/mfa`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete token
         * @param {string} userId User ID
         * @param {string} tokenId Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken: async (userId: string, tokenId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteToken', 'userId', userId)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('deleteToken', 'tokenId', tokenId)
            const localVarPath = `/user/{user_id}/tokens/{token_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes user from every organization
         * @summary Delete a User by UUID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request reset password
         * @param {InlineObject12} inlineObject12 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword: async (inlineObject12: InlineObject12, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject12' is not null or undefined
            assertParamExists('forgotPassword', 'inlineObject12', inlineObject12)
            const localVarPath = `/users/forgot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject12, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserById', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List authorization tokens
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTokens: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listTokens', 'userId', userId)
            const localVarPath = `/user/{user_id}/tokens`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List User Activity
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserActivity: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listUserActivity', 'userId', userId)
            const localVarPath = `/users/{user_id}/activity`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validates an MFA configuration request
         * @param {string} userId User ID
         * @param {InlineObject18} inlineObject18 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mfaVerify: async (userId: string, inlineObject18: InlineObject18, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('mfaVerify', 'userId', userId)
            // verify required parameter 'inlineObject18' is not null or undefined
            assertParamExists('mfaVerify', 'inlineObject18', inlineObject18)
            const localVarPath = `/user/{user_id}/mfa/verify`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject18, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Report User Activity
         * @param {string} userId User ID
         * @param {InlineObject16} inlineObject16 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportUserActivity: async (userId: string, inlineObject16: InlineObject16, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('reportUserActivity', 'userId', userId)
            // verify required parameter 'inlineObject16' is not null or undefined
            assertParamExists('reportUserActivity', 'inlineObject16', inlineObject16)
            const localVarPath = `/users/{user_id}/activity`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject16, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request reset password using token
         * @param {string} token Reset token
         * @param {InlineObject13} inlineObject13 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (token: string, inlineObject13: InlineObject13, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('resetPassword', 'token', token)
            // verify required parameter 'inlineObject13' is not null or undefined
            assertParamExists('resetPassword', 'inlineObject13', inlineObject13)
            const localVarPath = `/users/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject13, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set a user primary organization
         * @param {string} organizationId Organization ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserPrimaryOrganization: async (organizationId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('setUserPrimaryOrganization', 'organizationId', organizationId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('setUserPrimaryOrganization', 'userId', userId)
            const localVarPath = `/user/{user_id}/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user information (except password)
         * @param {string} userId User ID
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserById: async (userId: string, user: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserById', 'userId', userId)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateUserById', 'user', user)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user password
         * @param {string} userId User ID
         * @param {InlineObject15} inlineObject15 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword: async (userId: string, inlineObject15: InlineObject15, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserPassword', 'userId', userId)
            // verify required parameter 'inlineObject15' is not null or undefined
            assertParamExists('updateUserPassword', 'inlineObject15', inlineObject15)
            const localVarPath = `/users/{user_id}/password`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject15, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user profile name
         * @param {string} userId User ID
         * @param {InlineObject14} inlineObject14 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserProfile: async (userId: string, inlineObject14: InlineObject14, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserProfile', 'userId', userId)
            // verify required parameter 'inlineObject14' is not null or undefined
            assertParamExists('updateUserProfile', 'inlineObject14', inlineObject14)
            const localVarPath = `/users/{user_id}/profile`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject14, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Initalizes user MFA configuration workflow
         * @param {string} userId User ID
         * @param {InlineObject17} inlineObject17 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configureMfa(userId: string, inlineObject17: InlineObject17, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configureMfa(userId, inlineObject17, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create authorization token
         * @param {string} userId User ID
         * @param {InlineObject19} inlineObject19 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createToken(userId: string, inlineObject19: InlineObject19, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createToken(userId, inlineObject19, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes user MFA configuration workflow
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMfa(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMfa(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete token
         * @param {string} userId User ID
         * @param {string} tokenId Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteToken(userId: string, tokenId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteToken(userId, tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes user from every organization
         * @summary Delete a User by UUID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request reset password
         * @param {InlineObject12} inlineObject12 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPassword(inlineObject12: InlineObject12, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgotPassword(inlineObject12, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get User
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List authorization tokens
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTokens(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTokens(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List User Activity
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserActivity(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserActivity(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Validates an MFA configuration request
         * @param {string} userId User ID
         * @param {InlineObject18} inlineObject18 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mfaVerify(userId: string, inlineObject18: InlineObject18, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mfaVerify(userId, inlineObject18, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Report User Activity
         * @param {string} userId User ID
         * @param {InlineObject16} inlineObject16 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportUserActivity(userId: string, inlineObject16: InlineObject16, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportUserActivity(userId, inlineObject16, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request reset password using token
         * @param {string} token Reset token
         * @param {InlineObject13} inlineObject13 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(token: string, inlineObject13: InlineObject13, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(token, inlineObject13, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set a user primary organization
         * @param {string} organizationId Organization ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserPrimaryOrganization(organizationId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserPrimaryOrganization(organizationId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user information (except password)
         * @param {string} userId User ID
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserById(userId: string, user: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserById(userId, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user password
         * @param {string} userId User ID
         * @param {InlineObject15} inlineObject15 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPassword(userId: string, inlineObject15: InlineObject15, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPassword(userId, inlineObject15, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user profile name
         * @param {string} userId User ID
         * @param {InlineObject14} inlineObject14 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserProfile(userId: string, inlineObject14: InlineObject14, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserProfile(userId, inlineObject14, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Initalizes user MFA configuration workflow
         * @param {string} userId User ID
         * @param {InlineObject17} inlineObject17 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureMfa(userId: string, inlineObject17: InlineObject17, options?: any): AxiosPromise<void> {
            return localVarFp.configureMfa(userId, inlineObject17, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create authorization token
         * @param {string} userId User ID
         * @param {InlineObject19} inlineObject19 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createToken(userId: string, inlineObject19: InlineObject19, options?: any): AxiosPromise<Token> {
            return localVarFp.createToken(userId, inlineObject19, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes user MFA configuration workflow
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMfa(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMfa(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete token
         * @param {string} userId User ID
         * @param {string} tokenId Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken(userId: string, tokenId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteToken(userId, tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes user from every organization
         * @summary Delete a User by UUID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request reset password
         * @param {InlineObject12} inlineObject12 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword(inlineObject12: InlineObject12, options?: any): AxiosPromise<void> {
            return localVarFp.forgotPassword(inlineObject12, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(userId: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List authorization tokens
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTokens(userId: string, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.listTokens(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List User Activity
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserActivity(userId: string, options?: any): AxiosPromise<User> {
            return localVarFp.listUserActivity(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validates an MFA configuration request
         * @param {string} userId User ID
         * @param {InlineObject18} inlineObject18 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mfaVerify(userId: string, inlineObject18: InlineObject18, options?: any): AxiosPromise<void> {
            return localVarFp.mfaVerify(userId, inlineObject18, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Report User Activity
         * @param {string} userId User ID
         * @param {InlineObject16} inlineObject16 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportUserActivity(userId: string, inlineObject16: InlineObject16, options?: any): AxiosPromise<User> {
            return localVarFp.reportUserActivity(userId, inlineObject16, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request reset password using token
         * @param {string} token Reset token
         * @param {InlineObject13} inlineObject13 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(token: string, inlineObject13: InlineObject13, options?: any): AxiosPromise<void> {
            return localVarFp.resetPassword(token, inlineObject13, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set a user primary organization
         * @param {string} organizationId Organization ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserPrimaryOrganization(organizationId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.setUserPrimaryOrganization(organizationId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user information (except password)
         * @param {string} userId User ID
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserById(userId: string, user: User, options?: any): AxiosPromise<User> {
            return localVarFp.updateUserById(userId, user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user password
         * @param {string} userId User ID
         * @param {InlineObject15} inlineObject15 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword(userId: string, inlineObject15: InlineObject15, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserPassword(userId, inlineObject15, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user profile name
         * @param {string} userId User ID
         * @param {InlineObject14} inlineObject14 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserProfile(userId: string, inlineObject14: InlineObject14, options?: any): AxiosPromise<User> {
            return localVarFp.updateUserProfile(userId, inlineObject14, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Initalizes user MFA configuration workflow
     * @param {string} userId User ID
     * @param {InlineObject17} inlineObject17 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public configureMfa(userId: string, inlineObject17: InlineObject17, options?: any) {
        return UserApiFp(this.configuration).configureMfa(userId, inlineObject17, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create authorization token
     * @param {string} userId User ID
     * @param {InlineObject19} inlineObject19 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createToken(userId: string, inlineObject19: InlineObject19, options?: any) {
        return UserApiFp(this.configuration).createToken(userId, inlineObject19, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes user MFA configuration workflow
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteMfa(userId: string, options?: any) {
        return UserApiFp(this.configuration).deleteMfa(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete token
     * @param {string} userId User ID
     * @param {string} tokenId Token ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteToken(userId: string, tokenId: string, options?: any) {
        return UserApiFp(this.configuration).deleteToken(userId, tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes user from every organization
     * @summary Delete a User by UUID
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(userId: string, options?: any) {
        return UserApiFp(this.configuration).deleteUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request reset password
     * @param {InlineObject12} inlineObject12 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public forgotPassword(inlineObject12: InlineObject12, options?: any) {
        return UserApiFp(this.configuration).forgotPassword(inlineObject12, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserById(userId: string, options?: any) {
        return UserApiFp(this.configuration).getUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List authorization tokens
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listTokens(userId: string, options?: any) {
        return UserApiFp(this.configuration).listTokens(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List User Activity
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listUserActivity(userId: string, options?: any) {
        return UserApiFp(this.configuration).listUserActivity(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validates an MFA configuration request
     * @param {string} userId User ID
     * @param {InlineObject18} inlineObject18 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public mfaVerify(userId: string, inlineObject18: InlineObject18, options?: any) {
        return UserApiFp(this.configuration).mfaVerify(userId, inlineObject18, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Report User Activity
     * @param {string} userId User ID
     * @param {InlineObject16} inlineObject16 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public reportUserActivity(userId: string, inlineObject16: InlineObject16, options?: any) {
        return UserApiFp(this.configuration).reportUserActivity(userId, inlineObject16, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request reset password using token
     * @param {string} token Reset token
     * @param {InlineObject13} inlineObject13 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public resetPassword(token: string, inlineObject13: InlineObject13, options?: any) {
        return UserApiFp(this.configuration).resetPassword(token, inlineObject13, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set a user primary organization
     * @param {string} organizationId Organization ID
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public setUserPrimaryOrganization(organizationId: string, userId: string, options?: any) {
        return UserApiFp(this.configuration).setUserPrimaryOrganization(organizationId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user information (except password)
     * @param {string} userId User ID
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserById(userId: string, user: User, options?: any) {
        return UserApiFp(this.configuration).updateUserById(userId, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user password
     * @param {string} userId User ID
     * @param {InlineObject15} inlineObject15 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserPassword(userId: string, inlineObject15: InlineObject15, options?: any) {
        return UserApiFp(this.configuration).updateUserPassword(userId, inlineObject15, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user profile name
     * @param {string} userId User ID
     * @param {InlineObject14} inlineObject14 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserProfile(userId: string, inlineObject14: InlineObject14, options?: any) {
        return UserApiFp(this.configuration).updateUserProfile(userId, inlineObject14, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add an existing user to an organization
         * @param {string} organizationId Organization ID
         * @param {InlineObject8} inlineObject8 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserOrganization: async (organizationId: string, inlineObject8: InlineObject8, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addUserOrganization', 'organizationId', organizationId)
            // verify required parameter 'inlineObject8' is not null or undefined
            assertParamExists('addUserOrganization', 'inlineObject8', inlineObject8)
            const localVarPath = `/organizations/{organization_id}/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject8, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create organization groups
         * @param {string} organizationId Organization ID
         * @param {UserGroup} userGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationGroup: async (organizationId: string, userGroup: UserGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createOrganizationGroup', 'organizationId', organizationId)
            // verify required parameter 'userGroup' is not null or undefined
            assertParamExists('createOrganizationGroup', 'userGroup', userGroup)
            const localVarPath = `/organizations/{organization_id}/groups`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete organization group
         * @param {string} organizationId Organization ID
         * @param {string} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationGroup: async (organizationId: string, groupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganizationGroup', 'organizationId', organizationId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteOrganizationGroup', 'groupId', groupId)
            const localVarPath = `/organizations/{organization_id}/groups/{group_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove organization user
         * @param {string} organizationId Organization ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationUser: async (organizationId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganizationUser', 'organizationId', organizationId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteOrganizationUser', 'userId', userId)
            const localVarPath = `/organizations/{organization_id}/users/{user_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find an organization user by email
         * @param {string} organizationId Organization ID
         * @param {InlineObject10} inlineObject10 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrganizationUserByEmail: async (organizationId: string, inlineObject10: InlineObject10, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findOrganizationUserByEmail', 'organizationId', organizationId)
            // verify required parameter 'inlineObject10' is not null or undefined
            assertParamExists('findOrganizationUserByEmail', 'inlineObject10', inlineObject10)
            const localVarPath = `/organizations/{organization_id}/users/find`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject10, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate a list of users that have access to a project
         * @param {string} organizationId Organization ID
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationProjectUserList: async (organizationId: string, projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationProjectUserList', 'organizationId', organizationId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getOrganizationProjectUserList', 'projectId', projectId)
            const localVarPath = `/organizations/{organization_id}/users/projects/{project_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List users that belong to a organization
         * @param {string} organizationId Organization ID
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUsers: async (organizationId: string, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationUsers', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invites a new user to an organization
         * @param {string} organizationId Organization ID
         * @param {InlineObject9} inlineObject9 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUserOrganization: async (organizationId: string, inlineObject9: InlineObject9, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('inviteUserOrganization', 'organizationId', organizationId)
            // verify required parameter 'inlineObject9' is not null or undefined
            assertParamExists('inviteUserOrganization', 'inlineObject9', inlineObject9)
            const localVarPath = `/organizations/{organization_id}/users/invite`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject9, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization groups
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationGroups: async (organizationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationGroups', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/groups`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update organization group
         * @param {string} organizationId Organization ID
         * @param {string} groupId Group ID
         * @param {UserGroup} userGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationGroup: async (organizationId: string, groupId: string, userGroup: UserGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganizationGroup', 'organizationId', organizationId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateOrganizationGroup', 'groupId', groupId)
            // verify required parameter 'userGroup' is not null or undefined
            assertParamExists('updateOrganizationGroup', 'userGroup', userGroup)
            const localVarPath = `/organizations/{organization_id}/groups/{group_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update organization user
         * @param {string} organizationId Organization ID
         * @param {string} userId User ID
         * @param {InlineObject11} inlineObject11 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationUser: async (organizationId: string, userId: string, inlineObject11: InlineObject11, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganizationUser', 'organizationId', organizationId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateOrganizationUser', 'userId', userId)
            // verify required parameter 'inlineObject11' is not null or undefined
            assertParamExists('updateOrganizationUser', 'inlineObject11', inlineObject11)
            const localVarPath = `/organizations/{organization_id}/users/{user_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject11, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add an existing user to an organization
         * @param {string} organizationId Organization ID
         * @param {InlineObject8} inlineObject8 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserOrganization(organizationId: string, inlineObject8: InlineObject8, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserOrganization(organizationId, inlineObject8, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create organization groups
         * @param {string} organizationId Organization ID
         * @param {UserGroup} userGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationGroup(organizationId: string, userGroup: UserGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationGroup(organizationId, userGroup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete organization group
         * @param {string} organizationId Organization ID
         * @param {string} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationGroup(organizationId: string, groupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationGroup(organizationId, groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove organization user
         * @param {string} organizationId Organization ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationUser(organizationId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationUser(organizationId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find an organization user by email
         * @param {string} organizationId Organization ID
         * @param {InlineObject10} inlineObject10 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOrganizationUserByEmail(organizationId: string, inlineObject10: InlineObject10, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOrganizationUserByEmail(organizationId, inlineObject10, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate a list of users that have access to a project
         * @param {string} organizationId Organization ID
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationProjectUserList(organizationId: string, projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationProjectUserList(organizationId, projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List users that belong to a organization
         * @param {string} organizationId Organization ID
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationUsers(organizationId: string, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationUsers(organizationId, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invites a new user to an organization
         * @param {string} organizationId Organization ID
         * @param {InlineObject9} inlineObject9 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteUserOrganization(organizationId: string, inlineObject9: InlineObject9, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteUserOrganization(organizationId, inlineObject9, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List organization groups
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationGroups(organizationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationGroups(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update organization group
         * @param {string} organizationId Organization ID
         * @param {string} groupId Group ID
         * @param {UserGroup} userGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationGroup(organizationId: string, groupId: string, userGroup: UserGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationGroup(organizationId, groupId, userGroup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update organization user
         * @param {string} organizationId Organization ID
         * @param {string} userId User ID
         * @param {InlineObject11} inlineObject11 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationUser(organizationId: string, userId: string, inlineObject11: InlineObject11, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationUser(organizationId, userId, inlineObject11, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Add an existing user to an organization
         * @param {string} organizationId Organization ID
         * @param {InlineObject8} inlineObject8 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserOrganization(organizationId: string, inlineObject8: InlineObject8, options?: any): AxiosPromise<void> {
            return localVarFp.addUserOrganization(organizationId, inlineObject8, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create organization groups
         * @param {string} organizationId Organization ID
         * @param {UserGroup} userGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationGroup(organizationId: string, userGroup: UserGroup, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.createOrganizationGroup(organizationId, userGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete organization group
         * @param {string} organizationId Organization ID
         * @param {string} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationGroup(organizationId: string, groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationGroup(organizationId, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove organization user
         * @param {string} organizationId Organization ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationUser(organizationId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationUser(organizationId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find an organization user by email
         * @param {string} organizationId Organization ID
         * @param {InlineObject10} inlineObject10 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrganizationUserByEmail(organizationId: string, inlineObject10: InlineObject10, options?: any): AxiosPromise<void> {
            return localVarFp.findOrganizationUserByEmail(organizationId, inlineObject10, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.getAllUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate a list of users that have access to a project
         * @param {string} organizationId Organization ID
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationProjectUserList(organizationId: string, projectId: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.getOrganizationProjectUserList(organizationId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List users that belong to a organization
         * @param {string} organizationId Organization ID
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUsers(organizationId: string, offset?: number, limit?: number, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.getOrganizationUsers(organizationId, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invites a new user to an organization
         * @param {string} organizationId Organization ID
         * @param {InlineObject9} inlineObject9 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUserOrganization(organizationId: string, inlineObject9: InlineObject9, options?: any): AxiosPromise<void> {
            return localVarFp.inviteUserOrganization(organizationId, inlineObject9, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization groups
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationGroups(organizationId: string, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.listOrganizationGroups(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update organization group
         * @param {string} organizationId Organization ID
         * @param {string} groupId Group ID
         * @param {UserGroup} userGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationGroup(organizationId: string, groupId: string, userGroup: UserGroup, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.updateOrganizationGroup(organizationId, groupId, userGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update organization user
         * @param {string} organizationId Organization ID
         * @param {string} userId User ID
         * @param {InlineObject11} inlineObject11 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationUser(organizationId: string, userId: string, inlineObject11: InlineObject11, options?: any): AxiosPromise<void> {
            return localVarFp.updateOrganizationUser(organizationId, userId, inlineObject11, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Add an existing user to an organization
     * @param {string} organizationId Organization ID
     * @param {InlineObject8} inlineObject8 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public addUserOrganization(organizationId: string, inlineObject8: InlineObject8, options?: any) {
        return UsersApiFp(this.configuration).addUserOrganization(organizationId, inlineObject8, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create organization groups
     * @param {string} organizationId Organization ID
     * @param {UserGroup} userGroup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createOrganizationGroup(organizationId: string, userGroup: UserGroup, options?: any) {
        return UsersApiFp(this.configuration).createOrganizationGroup(organizationId, userGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete organization group
     * @param {string} organizationId Organization ID
     * @param {string} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteOrganizationGroup(organizationId: string, groupId: string, options?: any) {
        return UsersApiFp(this.configuration).deleteOrganizationGroup(organizationId, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove organization user
     * @param {string} organizationId Organization ID
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteOrganizationUser(organizationId: string, userId: string, options?: any) {
        return UsersApiFp(this.configuration).deleteOrganizationUser(organizationId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find an organization user by email
     * @param {string} organizationId Organization ID
     * @param {InlineObject10} inlineObject10 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findOrganizationUserByEmail(organizationId: string, inlineObject10: InlineObject10, options?: any) {
        return UsersApiFp(this.configuration).findOrganizationUserByEmail(organizationId, inlineObject10, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getAllUsers(options?: any) {
        return UsersApiFp(this.configuration).getAllUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate a list of users that have access to a project
     * @param {string} organizationId Organization ID
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getOrganizationProjectUserList(organizationId: string, projectId: string, options?: any) {
        return UsersApiFp(this.configuration).getOrganizationProjectUserList(organizationId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List users that belong to a organization
     * @param {string} organizationId Organization ID
     * @param {number} [offset] Offset
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getOrganizationUsers(organizationId: string, offset?: number, limit?: number, options?: any) {
        return UsersApiFp(this.configuration).getOrganizationUsers(organizationId, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invites a new user to an organization
     * @param {string} organizationId Organization ID
     * @param {InlineObject9} inlineObject9 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public inviteUserOrganization(organizationId: string, inlineObject9: InlineObject9, options?: any) {
        return UsersApiFp(this.configuration).inviteUserOrganization(organizationId, inlineObject9, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization groups
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listOrganizationGroups(organizationId: string, options?: any) {
        return UsersApiFp(this.configuration).listOrganizationGroups(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update organization group
     * @param {string} organizationId Organization ID
     * @param {string} groupId Group ID
     * @param {UserGroup} userGroup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateOrganizationGroup(organizationId: string, groupId: string, userGroup: UserGroup, options?: any) {
        return UsersApiFp(this.configuration).updateOrganizationGroup(organizationId, groupId, userGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update organization user
     * @param {string} organizationId Organization ID
     * @param {string} userId User ID
     * @param {InlineObject11} inlineObject11 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateOrganizationUser(organizationId: string, userId: string, inlineObject11: InlineObject11, options?: any) {
        return UsersApiFp(this.configuration).updateOrganizationUser(organizationId, userId, inlineObject11, options).then((request) => request(this.axios, this.basePath));
    }
}


