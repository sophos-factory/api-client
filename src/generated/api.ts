/* tslint:disable */
/* eslint-disable */
/**
 * Sophos Factory API v1
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@refactr.it
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface CatalogAccess
 */
export interface CatalogAccess {
    /**
     * 
     * @type {string}
     * @memberof CatalogAccess
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogAccess
     */
    organization_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogAccess
     */
    shared_organization_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogAccess
     */
    catalog_id?: string;
    /**
     * 
     * @type {InlineResponse20011Projects}
     * @memberof CatalogAccess
     */
    organization?: InlineResponse20011Projects;
}
/**
 * 
 * @export
 * @interface CatalogAccessRequest
 */
export interface CatalogAccessRequest {
    /**
     * 
     * @type {string}
     * @memberof CatalogAccessRequest
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogAccessRequest
     */
    organization_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogAccessRequest
     */
    catalog_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogAccessRequest
     */
    shared_organization_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogAccessRequest
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogAccessRequest
     */
    status?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CatalogTags {
    ChatOps = 'ChatOps',
    CloudInfrastructure = 'Cloud Infrastructure',
    DevOps = 'DevOps',
    ItOps = 'ITOps',
    NetworkAutomation = 'Network Automation',
    SecurityAutomation = 'Security Automation',
    MlOps = 'MLOps'
}

/**
 * 
 * @export
 * @interface Credential
 */
export interface Credential {
    /**
     * 
     * @type {string}
     * @memberof Credential
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof Credential
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Credential
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Credential
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Credential
     */
    type?: CredentialTypeEnum;
    /**
     * 
     * @type {object}
     * @memberof Credential
     */
    data?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum CredentialTypeEnum {
    Generic = 'generic',
    UsernamePassword = 'username_password',
    SshKey = 'ssh_key',
    BearerToken = 'bearer_token',
    ApiToken = 'api_token',
    AzureServicePrincipal = 'azure_service_principal',
    GoogleServiceAccount = 'google_service_account',
    AwsAccessKey = 'aws_access_key',
    VaultAppRole = 'vault_app_role',
    CisLicenseBundle = 'cis_license_bundle'
}

/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject
     */
    expire?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    expire_unit?: InlineObjectExpireUnitEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObjectExpireUnitEnum {
    Hours = 'hours',
    Days = 'days',
    Years = 'years'
}

/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface InlineObject10
 */
export interface InlineObject10 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject10
     */
    project_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject10
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject10
     */
    recursive?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject11
 */
export interface InlineObject11 {
    /**
     * 
     * @type {object}
     * @memberof InlineObject11
     */
    variables?: object;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject11
     */
    suppress_vars?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject11
     */
    suppress_events?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject11
     */
    suppress_outputs?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject12
 */
export interface InlineObject12 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface InlineObject13
 */
export interface InlineObject13 {
    /**
     * 
     * @type {object}
     * @memberof InlineObject13
     */
    variables?: object;
    /**
     * Whether to suppress run output
     * @type {boolean}
     * @memberof InlineObject13
     */
    suppress_outputs?: boolean;
    /**
     * Whether to suppress run events
     * @type {boolean}
     * @memberof InlineObject13
     */
    suppress_events?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject14
 */
export interface InlineObject14 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject14
     */
    retained?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject15
 */
export interface InlineObject15 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject15
     */
    catalog?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineObject15
     */
    catalog_scope?: string;
}
/**
 * 
 * @export
 * @interface InlineObject16
 */
export interface InlineObject16 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject16
     */
    shared_organization_id?: string;
}
/**
 * 
 * @export
 * @interface InlineObject17
 */
export interface InlineObject17 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject17
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface InlineObject18
 */
export interface InlineObject18 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject18
     */
    email?: string;
    /**
     * 
     * @type {Set<string>}
     * @memberof InlineObject18
     */
    group_ids?: Set<string>;
}
/**
 * 
 * @export
 * @interface InlineObject19
 */
export interface InlineObject19 {
    /**
     * 
     * @type {Set<string>}
     * @memberof InlineObject19
     */
    group_ids?: Set<string>;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    current_password?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    confirm_password?: string;
}
/**
 * 
 * @export
 * @interface InlineObject20
 */
export interface InlineObject20 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject20
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject20
     */
    type?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject20
     */
    project_ids?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineObject21
 */
export interface InlineObject21 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject21
     */
    name?: string;
    /**
     * 
     * @type {OrganizationsOrganizationIdAgentsIdOptions}
     * @memberof InlineObject21
     */
    options?: OrganizationsOrganizationIdAgentsIdOptions;
}
/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    role?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject3
     */
    run?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    role?: InlineObject4RoleEnum;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject4
     */
    run?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject4RoleEnum {
    Read = 'read',
    Write = 'write',
    Admin = 'admin'
}

/**
 * 
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    group_id: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    role: InlineObject5RoleEnum;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject5
     */
    run: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject5RoleEnum {
    Read = 'read',
    Write = 'write',
    Admin = 'admin'
}

/**
 * 
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    role?: InlineObject6RoleEnum;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject6
     */
    run?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject6RoleEnum {
    Read = 'read',
    Write = 'write',
    Admin = 'admin'
}

/**
 * 
 * @export
 * @interface InlineObject7
 */
export interface InlineObject7 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject7
     */
    comment?: string;
}
/**
 * 
 * @export
 * @interface InlineObject8
 */
export interface InlineObject8 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    project_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject8
     */
    recursive?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject9
 */
export interface InlineObject9 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    project_id?: string;
    /**
     * 
     * @type {object}
     * @memberof InlineObject9
     */
    variables?: object;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject9
     */
    suppress_vars?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject9
     */
    suppress_events?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject9
     */
    suppress_outputs?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Array<Token>}
     * @memberof InlineResponse200
     */
    tokens?: Array<Token>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Array<UserActivity>}
     * @memberof InlineResponse2001
     */
    user_activity?: Array<UserActivity>;
}
/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * 
     * @type {Array<Credential>}
     * @memberof InlineResponse20010
     */
    credentials?: Array<Credential>;
}
/**
 * 
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     * 
     * @type {Array<InlineResponse20011Projects>}
     * @memberof InlineResponse20011
     */
    projects?: Array<InlineResponse20011Projects>;
}
/**
 * 
 * @export
 * @interface InlineResponse20011Projects
 */
export interface InlineResponse20011Projects {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011Projects
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011Projects
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011Projects
     */
    image_id?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     * 
     * @type {Array<Job>}
     * @memberof InlineResponse20012
     */
    jobs?: Array<Job>;
}
/**
 * 
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
    /**
     * 
     * @type {Array<RunnerAgent>}
     * @memberof InlineResponse20013
     */
    runner_agents?: Array<RunnerAgent>;
}
/**
 * 
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
    /**
     * 
     * @type {Array<Run>}
     * @memberof InlineResponse20014
     */
    runs?: Array<Run>;
}
/**
 * 
 * @export
 * @interface InlineResponse20015
 */
export interface InlineResponse20015 {
    /**
     * 
     * @type {Array<Organization>}
     * @memberof InlineResponse20015
     */
    organizations?: Array<Organization>;
}
/**
 * 
 * @export
 * @interface InlineResponse20016
 */
export interface InlineResponse20016 {
    /**
     * 
     * @type {Array<CatalogAccessRequest>}
     * @memberof InlineResponse20016
     */
    users?: Array<CatalogAccessRequest>;
}
/**
 * 
 * @export
 * @interface InlineResponse20017
 */
export interface InlineResponse20017 {
    /**
     * 
     * @type {Array<CatalogAccess>}
     * @memberof InlineResponse20017
     */
    catalog_access?: Array<CatalogAccess>;
}
/**
 * 
 * @export
 * @interface InlineResponse20018
 */
export interface InlineResponse20018 {
    /**
     * 
     * @type {Array<OrganizationInvite>}
     * @memberof InlineResponse20018
     */
    users?: Array<OrganizationInvite>;
}
/**
 * 
 * @export
 * @interface InlineResponse20019
 */
export interface InlineResponse20019 {
    /**
     * 
     * @type {Array<UserGroup>}
     * @memberof InlineResponse20019
     */
    users?: Array<UserGroup>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {Array<User>}
     * @memberof InlineResponse2002
     */
    users?: Array<User>;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {Array<InlineResponse2003Users>}
     * @memberof InlineResponse2003
     */
    users?: Array<InlineResponse2003Users>;
}
/**
 * 
 * @export
 * @interface InlineResponse2003Users
 */
export interface InlineResponse2003Users {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Users
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Users
     */
    group_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Users
     */
    role?: InlineResponse2003UsersRoleEnum;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2003Users
     */
    run?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2003UsersRoleEnum {
    Read = 'read',
    Write = 'write',
    Admin = 'admin'
}

/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {Array<ProjectInvite>}
     * @memberof InlineResponse2004
     */
    users?: Array<ProjectInvite>;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {Array<Pipeline>}
     * @memberof InlineResponse2005
     */
    pipelines?: Array<Pipeline>;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {Array<PipelineRevision>}
     * @memberof InlineResponse2006
     */
    pipeline_revisions?: Array<PipelineRevision>;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2007
     */
    revision?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {Array<PipelineRevision>}
     * @memberof InlineResponse2008
     */
    pipelines?: Array<PipelineRevision>;
}
/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * 
     * @type {Array<Project>}
     * @memberof InlineResponse2009
     */
    projects?: Array<Project>;
}
/**
 * 
 * @export
 * @interface InlineResponse201
 */
export interface InlineResponse201 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse201
     */
    _id?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2011
 */
export interface InlineResponse2011 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2011
     */
    _id?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2011
     */
    revision?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2012
 */
export interface InlineResponse2012 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2012
     */
    agent_key?: string;
}
/**
 * 
 * @export
 * @interface Job
 */
export interface Job {
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    project_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    pipeline_id: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    pipeline_revision_id?: string;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    pipeline_version_id?: number;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    number?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Job
     */
    enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Job
     */
    pinned?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    trigger_type: JobTriggerTypeEnum;
    /**
     * 
     * @type {JobSchedule}
     * @memberof Job
     */
    schedule?: JobSchedule;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    webhook_type?: JobWebhookTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    webhook_token?: string;
    /**
     * 
     * @type {object}
     * @memberof Job
     */
    webhook?: object;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    pipeline_catalog_id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Job
     */
    suppress_outputs?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Job
     */
    suppress_vars?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Job
     */
    suppress_events?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Job
     */
    disable_on_failure?: boolean;
    /**
     * 
     * @type {object}
     * @memberof Job
     */
    variables?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum JobTriggerTypeEnum {
    Manual = 'manual',
    Scheduled = 'scheduled',
    Webhook = 'webhook'
}
/**
    * @export
    * @enum {string}
    */
export enum JobWebhookTypeEnum {
    Custom = 'custom',
    Github = 'github',
    Gitlab = 'gitlab',
    Bitbucket = 'bitbucket',
    TerraformRunTask = 'terraform_run_task'
}

/**
 * 
 * @export
 * @interface JobSchedule
 */
export interface JobSchedule {
    /**
     * 
     * @type {string}
     * @memberof JobSchedule
     */
    start_day?: string;
    /**
     * 
     * @type {string}
     * @memberof JobSchedule
     */
    start_time?: string;
    /**
     * 
     * @type {string}
     * @memberof JobSchedule
     */
    offset?: string;
    /**
     * 
     * @type {number}
     * @memberof JobSchedule
     */
    interval?: number;
    /**
     * 
     * @type {string}
     * @memberof JobSchedule
     */
    interval_type?: JobScheduleIntervalTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum JobScheduleIntervalTypeEnum {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day',
    Week = 'week',
    Month = 'month'
}

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    details?: string;
}
/**
 * 
 * @export
 * @interface NotificationChannel
 */
export interface NotificationChannel {
    /**
     * 
     * @type {string}
     * @memberof NotificationChannel
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationChannel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationChannel
     */
    type?: NotificationChannelTypeEnum;
    /**
     * 
     * @type {NotificationChannelSettings}
     * @memberof NotificationChannel
     */
    settings?: NotificationChannelSettings;
    /**
     * 
     * @type {Array<string>}
     * @memberof NotificationChannel
     */
    events?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof NotificationChannel
     */
    auth?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum NotificationChannelTypeEnum {
    Email = 'email'
}

/**
 * 
 * @export
 * @interface NotificationChannelSettings
 */
export interface NotificationChannelSettings {
    /**
     * 
     * @type {Array<string>}
     * @memberof NotificationChannelSettings
     */
    recipients?: Array<string>;
}
/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    modified?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    zip?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    contact_name?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    contact_email?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    image_id?: string;
    /**
     * 
     * @type {OrganizationPlanQuotas}
     * @memberof Organization
     */
    plan_quotas?: OrganizationPlanQuotas;
    /**
     * 
     * @type {Array<NotificationChannel>}
     * @memberof Organization
     */
    notification_channels?: Array<NotificationChannel>;
}
/**
 * 
 * @export
 * @interface OrganizationInvite
 */
export interface OrganizationInvite {
    /**
     * 
     * @type {string}
     * @memberof OrganizationInvite
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationInvite
     */
    organization_id?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationInvite
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationInvite
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationInvite
     */
    expires_at?: string;
}
/**
 * 
 * @export
 * @interface OrganizationPlanQuotas
 */
export interface OrganizationPlanQuotas {
    /**
     * 
     * @type {number}
     * @memberof OrganizationPlanQuotas
     */
    project_count?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationPlanQuotas
     */
    user_count?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationPlanQuotas
     */
    agent_count?: number;
}
/**
 * 
 * @export
 * @interface OrganizationsOrganizationIdAgentsIdOptions
 */
export interface OrganizationsOrganizationIdAgentsIdOptions {
    /**
     * 
     * @type {number}
     * @memberof OrganizationsOrganizationIdAgentsIdOptions
     */
    idle_ttl?: number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationsOrganizationIdAgentsIdOptions
     */
    startup_script?: string | null;
    /**
     * 
     * @type {Array<OrganizationsOrganizationIdAgentsIdOptionsEnv>}
     * @memberof OrganizationsOrganizationIdAgentsIdOptions
     */
    env?: Array<OrganizationsOrganizationIdAgentsIdOptionsEnv> | null;
}
/**
 * 
 * @export
 * @interface OrganizationsOrganizationIdAgentsIdOptionsEnv
 */
export interface OrganizationsOrganizationIdAgentsIdOptionsEnv {
    /**
     * 
     * @type {string}
     * @memberof OrganizationsOrganizationIdAgentsIdOptionsEnv
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationsOrganizationIdAgentsIdOptionsEnv
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface Pipeline
 */
export interface Pipeline {
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    modified?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Pipeline
     */
    _public?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Pipeline
     */
    pinned?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    summary?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    image_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    icon_name?: string;
    /**
     * 
     * @type {number}
     * @memberof Pipeline
     */
    revision_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Pipeline
     */
    step_count?: number;
}
/**
 * 
 * @export
 * @interface PipelineRevision
 */
export interface PipelineRevision {
    /**
     * 
     * @type {string}
     * @memberof PipelineRevision
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRevision
     */
    pipeline_id?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRevision
     */
    created?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelineRevision
     */
    revision?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PipelineRevision
     */
    published?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PipelineRevision
     */
    version?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineRevision
     */
    comment?: string;
    /**
     * 
     * @type {Array<PipelineRevisionSteps>}
     * @memberof PipelineRevision
     */
    steps?: Array<PipelineRevisionSteps>;
    /**
     * 
     * @type {Array<object>}
     * @memberof PipelineRevision
     */
    variables?: Array<object>;
    /**
     * 
     * @type {Array<PipelineRevisionOutputs>}
     * @memberof PipelineRevision
     */
    outputs?: Array<PipelineRevisionOutputs>;
    /**
     * 
     * @type {object}
     * @memberof PipelineRevision
     */
    layout?: object;
}
/**
 * 
 * @export
 * @interface PipelineRevisionOutputs
 */
export interface PipelineRevisionOutputs {
    /**
     * 
     * @type {string}
     * @memberof PipelineRevisionOutputs
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRevisionOutputs
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface PipelineRevisionSteps
 */
export interface PipelineRevisionSteps {
    /**
     * 
     * @type {string}
     * @memberof PipelineRevisionSteps
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRevisionSteps
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRevisionSteps
     */
    type?: string;
    /**
     * 
     * @type {object}
     * @memberof PipelineRevisionSteps
     */
    properties?: object;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    organization_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    modified?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    summary?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    image_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    icon_name?: string;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    pipeline_count?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof Project
     */
    variables?: Array<object>;
    /**
     * 
     * @type {Array<CatalogTags>}
     * @memberof Project
     */
    tags?: Array<CatalogTags>;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    published_pipeline_count?: number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    product_link?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    support_link?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    license_link?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    policy_link?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Project
     */
    catalog?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    catalog_scope?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Project
     */
    shared?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Project
     */
    pending_access_request?: boolean;
    /**
     * 
     * @type {Array<NotificationChannel>}
     * @memberof Project
     */
    notification_channels?: Array<NotificationChannel>;
}
/**
 * 
 * @export
 * @interface ProjectInvite
 */
export interface ProjectInvite {
    /**
     * 
     * @type {string}
     * @memberof ProjectInvite
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectInvite
     */
    project_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectInvite
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectInvite
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectInvite
     */
    expires_at?: string;
}
/**
 * 
 * @export
 * @interface Run
 */
export interface Run {
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    organization_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    job_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    started?: string;
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    finished?: string;
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    status?: RunStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Run
     */
    retained?: boolean;
    /**
     * 
     * @type {Array<RunOperations>}
     * @memberof Run
     */
    operations?: Array<RunOperations>;
    /**
     * 
     * @type {object}
     * @memberof Run
     */
    outputs?: object;
    /**
     * 
     * @type {boolean}
     * @memberof Run
     */
    suppress_events?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Run
     */
    suppress_outputs?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Run
     */
    suppress_vars?: boolean;
    /**
     * 
     * @type {Array<RunEvents>}
     * @memberof Run
     */
    events?: Array<RunEvents>;
}

/**
    * @export
    * @enum {string}
    */
export enum RunStatusEnum {
    Queued = 'Queued',
    Pending = 'Pending',
    Running = 'Running',
    Succeeded = 'Succeeded',
    Failed = 'Failed'
}

/**
 * 
 * @export
 * @interface RunEvents
 */
export interface RunEvents {
    /**
     * 
     * @type {string}
     * @memberof RunEvents
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof RunEvents
     */
    operation_id?: string;
    /**
     * 
     * @type {string}
     * @memberof RunEvents
     */
    occurred?: string;
    /**
     * 
     * @type {string}
     * @memberof RunEvents
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof RunEvents
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof RunEvents
     */
    details?: string;
    /**
     * 
     * @type {string}
     * @memberof RunEvents
     */
    level?: string;
    /**
     * 
     * @type {object}
     * @memberof RunEvents
     */
    output?: object;
}
/**
 * 
 * @export
 * @interface RunOperations
 */
export interface RunOperations {
    /**
     * 
     * @type {string}
     * @memberof RunOperations
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof RunOperations
     */
    pipeline_id?: string;
    /**
     * 
     * @type {string}
     * @memberof RunOperations
     */
    pipeline_revision_id?: string;
    /**
     * 
     * @type {string}
     * @memberof RunOperations
     */
    module_id?: string;
    /**
     * 
     * @type {string}
     * @memberof RunOperations
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof RunOperations
     */
    started?: string;
    /**
     * 
     * @type {string}
     * @memberof RunOperations
     */
    finished?: string;
    /**
     * 
     * @type {string}
     * @memberof RunOperations
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof RunOperations
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface RunnerAgent
 */
export interface RunnerAgent {
    /**
     * 
     * @type {string}
     * @memberof RunnerAgent
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof RunnerAgent
     */
    organization_id?: string;
    /**
     * 
     * @type {string}
     * @memberof RunnerAgent
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof RunnerAgent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof RunnerAgent
     */
    host_name?: string;
    /**
     * 
     * @type {string}
     * @memberof RunnerAgent
     */
    host_type?: string;
    /**
     * 
     * @type {string}
     * @memberof RunnerAgent
     */
    machine_type?: string;
    /**
     * 
     * @type {string}
     * @memberof RunnerAgent
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof RunnerAgent
     */
    started?: string;
    /**
     * 
     * @type {string}
     * @memberof RunnerAgent
     */
    heartbeat?: string;
    /**
     * 
     * @type {string}
     * @memberof RunnerAgent
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof RunnerAgent
     */
    idle_since?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RunnerAgent
     */
    stop_pending?: boolean;
    /**
     * 
     * @type {Array<RunnerAgentEvents>}
     * @memberof RunnerAgent
     */
    events?: Array<RunnerAgentEvents>;
    /**
     * 
     * @type {RunnerAgentOptions}
     * @memberof RunnerAgent
     */
    options?: RunnerAgentOptions;
}
/**
 * 
 * @export
 * @interface RunnerAgentEvents
 */
export interface RunnerAgentEvents {
    /**
     * 
     * @type {string}
     * @memberof RunnerAgentEvents
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof RunnerAgentEvents
     */
    occurred?: string;
    /**
     * 
     * @type {string}
     * @memberof RunnerAgentEvents
     */
    level?: string;
    /**
     * 
     * @type {string}
     * @memberof RunnerAgentEvents
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof RunnerAgentEvents
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof RunnerAgentEvents
     */
    details?: string;
}
/**
 * 
 * @export
 * @interface RunnerAgentOptions
 */
export interface RunnerAgentOptions {
    /**
     * 
     * @type {RunnerAgentOptionsOptions}
     * @memberof RunnerAgentOptions
     */
    options?: RunnerAgentOptionsOptions;
}
/**
 * 
 * @export
 * @interface RunnerAgentOptionsOptions
 */
export interface RunnerAgentOptionsOptions {
    /**
     * 
     * @type {number}
     * @memberof RunnerAgentOptionsOptions
     */
    idle_ttl?: number;
    /**
     * 
     * @type {string}
     * @memberof RunnerAgentOptionsOptions
     */
    startup_script?: string | null;
    /**
     * 
     * @type {Array<OrganizationsOrganizationIdAgentsIdOptionsEnv>}
     * @memberof RunnerAgentOptionsOptions
     */
    env?: Array<OrganizationsOrganizationIdAgentsIdOptionsEnv>;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof Token
     */
    expire?: number;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    expire_unit?: TokenExpireUnitEnum;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    token?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TokenExpireUnitEnum {
    Hours = 'hours',
    Days = 'days',
    Weeks = 'weeks',
    Years = 'years'
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    last_login?: string;
}
/**
 * 
 * @export
 * @interface UserActivity
 */
export interface UserActivity {
    /**
     * 
     * @type {string}
     * @memberof UserActivity
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserActivity
     */
    operation_id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserActivity
     */
    occurred?: string;
}
/**
 * 
 * @export
 * @interface UserGroup
 */
export interface UserGroup {
    /**
     * 
     * @type {string}
     * @memberof UserGroup
     */
    group_id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGroup
     */
    default_project_role?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserGroup
     */
    default_project_run: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserGroup
     */
    create_projects: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserGroup
     */
    organization_admin: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserGroup
     */
    user_count?: number;
}

/**
 * AgentsApi - axios parameter creator
 * @export
 */
export const AgentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create runner agent
         * @param {string} organizationId Organization ID
         * @param {InlineObject20} inlineObject20 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunnerAgent: async (organizationId: string, inlineObject20: InlineObject20, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createRunnerAgent', 'organizationId', organizationId)
            // verify required parameter 'inlineObject20' is not null or undefined
            assertParamExists('createRunnerAgent', 'inlineObject20', inlineObject20)
            const localVarPath = `/organizations/{organization_id}/agents`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject20, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete runner agent
         * @param {string} organizationId Organization ID
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunnerAgent: async (organizationId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteRunnerAgent', 'organizationId', organizationId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRunnerAgent', 'id', id)
            const localVarPath = `/organizations/{organization_id}/agents/{_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get agent
         * @param {string} organizationId Organization ID
         * @param {string} id Agent ID
         * @param {Array<'events' | 'options' | 'agent_key'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerAgent: async (organizationId: string, id: string, fields?: Array<'events' | 'options' | 'agent_key'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunnerAgent', 'organizationId', organizationId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRunnerAgent', 'id', id)
            const localVarPath = `/organizations/{organization_id}/agents/{_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all agents for an organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationRunnerAgents: async (organizationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationRunnerAgents', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/agents`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List agents associated with a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectRunnerAgents: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectRunnerAgents', 'projectId', projectId)
            const localVarPath = `/projects/{project_id}/agents`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regenerate runner agent key
         * @param {string} organizationId Organization ID
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateRunnerAgentKey: async (organizationId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('regenerateRunnerAgentKey', 'organizationId', organizationId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('regenerateRunnerAgentKey', 'id', id)
            const localVarPath = `/organizations/{organization_id}/agents/{_id}/key`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start runner agent
         * @param {string} organizationId Organization ID
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRunnerAgent: async (organizationId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('startRunnerAgent', 'organizationId', organizationId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startRunnerAgent', 'id', id)
            const localVarPath = `/organizations/{organization_id}/agents/{_id}/start`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop runner agent
         * @param {string} organizationId Organization ID
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRunnerAgent: async (organizationId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('stopRunnerAgent', 'organizationId', organizationId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stopRunnerAgent', 'id', id)
            const localVarPath = `/organizations/{organization_id}/agents/{_id}/stop`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update runner agent
         * @param {string} organizationId Organization ID
         * @param {string} id Agent ID
         * @param {InlineObject21} inlineObject21 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunnerAgent: async (organizationId: string, id: string, inlineObject21: InlineObject21, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateRunnerAgent', 'organizationId', organizationId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRunnerAgent', 'id', id)
            // verify required parameter 'inlineObject21' is not null or undefined
            assertParamExists('updateRunnerAgent', 'inlineObject21', inlineObject21)
            const localVarPath = `/organizations/{organization_id}/agents/{_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject21, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentsApi - functional programming interface
 * @export
 */
export const AgentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AgentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create runner agent
         * @param {string} organizationId Organization ID
         * @param {InlineObject20} inlineObject20 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRunnerAgent(organizationId: string, inlineObject20: InlineObject20, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRunnerAgent(organizationId, inlineObject20, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete runner agent
         * @param {string} organizationId Organization ID
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRunnerAgent(organizationId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRunnerAgent(organizationId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get agent
         * @param {string} organizationId Organization ID
         * @param {string} id Agent ID
         * @param {Array<'events' | 'options' | 'agent_key'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunnerAgent(organizationId: string, id: string, fields?: Array<'events' | 'options' | 'agent_key'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerAgent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunnerAgent(organizationId, id, fields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all agents for an organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationRunnerAgents(organizationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationRunnerAgents(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List agents associated with a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectRunnerAgents(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectRunnerAgents(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Regenerate runner agent key
         * @param {string} organizationId Organization ID
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regenerateRunnerAgentKey(organizationId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regenerateRunnerAgentKey(organizationId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start runner agent
         * @param {string} organizationId Organization ID
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRunnerAgent(organizationId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startRunnerAgent(organizationId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop runner agent
         * @param {string} organizationId Organization ID
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopRunnerAgent(organizationId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopRunnerAgent(organizationId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update runner agent
         * @param {string} organizationId Organization ID
         * @param {string} id Agent ID
         * @param {InlineObject21} inlineObject21 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRunnerAgent(organizationId: string, id: string, inlineObject21: InlineObject21, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRunnerAgent(organizationId, id, inlineObject21, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AgentsApi - factory interface
 * @export
 */
export const AgentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AgentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create runner agent
         * @param {string} organizationId Organization ID
         * @param {InlineObject20} inlineObject20 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunnerAgent(organizationId: string, inlineObject20: InlineObject20, options?: any): AxiosPromise<void> {
            return localVarFp.createRunnerAgent(organizationId, inlineObject20, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete runner agent
         * @param {string} organizationId Organization ID
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunnerAgent(organizationId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRunnerAgent(organizationId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get agent
         * @param {string} organizationId Organization ID
         * @param {string} id Agent ID
         * @param {Array<'events' | 'options' | 'agent_key'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerAgent(organizationId: string, id: string, fields?: Array<'events' | 'options' | 'agent_key'>, options?: any): AxiosPromise<RunnerAgent> {
            return localVarFp.getRunnerAgent(organizationId, id, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all agents for an organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationRunnerAgents(organizationId: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.listOrganizationRunnerAgents(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List agents associated with a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectRunnerAgents(projectId: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.listProjectRunnerAgents(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Regenerate runner agent key
         * @param {string} organizationId Organization ID
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateRunnerAgentKey(organizationId: string, id: string, options?: any): AxiosPromise<InlineResponse2012> {
            return localVarFp.regenerateRunnerAgentKey(organizationId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start runner agent
         * @param {string} organizationId Organization ID
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRunnerAgent(organizationId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.startRunnerAgent(organizationId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop runner agent
         * @param {string} organizationId Organization ID
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRunnerAgent(organizationId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.stopRunnerAgent(organizationId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update runner agent
         * @param {string} organizationId Organization ID
         * @param {string} id Agent ID
         * @param {InlineObject21} inlineObject21 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunnerAgent(organizationId: string, id: string, inlineObject21: InlineObject21, options?: any): AxiosPromise<void> {
            return localVarFp.updateRunnerAgent(organizationId, id, inlineObject21, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AgentsApi - object-oriented interface
 * @export
 * @class AgentsApi
 * @extends {BaseAPI}
 */
export class AgentsApi extends BaseAPI {
    /**
     * 
     * @summary Create runner agent
     * @param {string} organizationId Organization ID
     * @param {InlineObject20} inlineObject20 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public createRunnerAgent(organizationId: string, inlineObject20: InlineObject20, options?: any) {
        return AgentsApiFp(this.configuration).createRunnerAgent(organizationId, inlineObject20, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete runner agent
     * @param {string} organizationId Organization ID
     * @param {string} id Agent ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public deleteRunnerAgent(organizationId: string, id: string, options?: any) {
        return AgentsApiFp(this.configuration).deleteRunnerAgent(organizationId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get agent
     * @param {string} organizationId Organization ID
     * @param {string} id Agent ID
     * @param {Array<'events' | 'options' | 'agent_key'>} [fields] Additional fields to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public getRunnerAgent(organizationId: string, id: string, fields?: Array<'events' | 'options' | 'agent_key'>, options?: any) {
        return AgentsApiFp(this.configuration).getRunnerAgent(organizationId, id, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all agents for an organization
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public listOrganizationRunnerAgents(organizationId: string, options?: any) {
        return AgentsApiFp(this.configuration).listOrganizationRunnerAgents(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List agents associated with a project
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public listProjectRunnerAgents(projectId: string, options?: any) {
        return AgentsApiFp(this.configuration).listProjectRunnerAgents(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Regenerate runner agent key
     * @param {string} organizationId Organization ID
     * @param {string} id Agent ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public regenerateRunnerAgentKey(organizationId: string, id: string, options?: any) {
        return AgentsApiFp(this.configuration).regenerateRunnerAgentKey(organizationId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start runner agent
     * @param {string} organizationId Organization ID
     * @param {string} id Agent ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public startRunnerAgent(organizationId: string, id: string, options?: any) {
        return AgentsApiFp(this.configuration).startRunnerAgent(organizationId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop runner agent
     * @param {string} organizationId Organization ID
     * @param {string} id Agent ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public stopRunnerAgent(organizationId: string, id: string, options?: any) {
        return AgentsApiFp(this.configuration).stopRunnerAgent(organizationId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update runner agent
     * @param {string} organizationId Organization ID
     * @param {string} id Agent ID
     * @param {InlineObject21} inlineObject21 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public updateRunnerAgent(organizationId: string, id: string, inlineObject21: InlineObject21, options?: any) {
        return AgentsApiFp(this.configuration).updateRunnerAgent(organizationId, id, inlineObject21, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CatalogsApi - axios parameter creator
 * @export
 */
export const CatalogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clone catalog pipeline
         * @param {string} catalogId Catalog ID
         * @param {string} pipelineId Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {InlineObject8} inlineObject8 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneCatalogPipeline: async (catalogId: string, pipelineId: string, revisionId: string, inlineObject8: InlineObject8, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogId' is not null or undefined
            assertParamExists('cloneCatalogPipeline', 'catalogId', catalogId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('cloneCatalogPipeline', 'pipelineId', pipelineId)
            // verify required parameter 'revisionId' is not null or undefined
            assertParamExists('cloneCatalogPipeline', 'revisionId', revisionId)
            // verify required parameter 'inlineObject8' is not null or undefined
            assertParamExists('cloneCatalogPipeline', 'inlineObject8', inlineObject8)
            const localVarPath = `/catalogs/{catalog_id}/pipelines/{pipeline_id}/revisions/{revision_id}/clone`
                .replace(`{${"catalog_id"}}`, encodeURIComponent(String(catalogId)))
                .replace(`{${"pipeline_id"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"revision_id"}}`, encodeURIComponent(String(revisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject8, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a catalog access request
         * @param {string} organizationId Organization ID
         * @param {string} catalogId Catalog ID
         * @param {InlineObject16} inlineObject16 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCatalogAccessRequest: async (organizationId: string, catalogId: string, inlineObject16: InlineObject16, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createCatalogAccessRequest', 'organizationId', organizationId)
            // verify required parameter 'catalogId' is not null or undefined
            assertParamExists('createCatalogAccessRequest', 'catalogId', catalogId)
            // verify required parameter 'inlineObject16' is not null or undefined
            assertParamExists('createCatalogAccessRequest', 'inlineObject16', inlineObject16)
            const localVarPath = `/organizations/{organization_id}/catalogs/{catalog_id}/access_requests`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"catalog_id"}}`, encodeURIComponent(String(catalogId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject16, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get catalog
         * @param {string} catalogId Catalog ID
         * @param {Array<'organization'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalog: async (catalogId: string, fields?: Array<'organization'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogId' is not null or undefined
            assertParamExists('getCatalog', 'catalogId', catalogId)
            const localVarPath = `/catalogs/{catalog_id}`
                .replace(`{${"catalog_id"}}`, encodeURIComponent(String(catalogId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get catalog pipeline
         * @param {string} catalogId Catalog ID
         * @param {string} pipelineId Pipeline ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogPipeline: async (catalogId: string, pipelineId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogId' is not null or undefined
            assertParamExists('getCatalogPipeline', 'catalogId', catalogId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getCatalogPipeline', 'pipelineId', pipelineId)
            const localVarPath = `/catalogs/{catalog_id}/pipelines/{pipeline_id}`
                .replace(`{${"catalog_id"}}`, encodeURIComponent(String(catalogId)))
                .replace(`{${"pipeline_id"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get catalog pipeline revision
         * @param {string} catalogId Catalog ID
         * @param {string} pipelineId Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogPipelineRevision: async (catalogId: string, pipelineId: string, revisionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogId' is not null or undefined
            assertParamExists('getCatalogPipelineRevision', 'catalogId', catalogId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getCatalogPipelineRevision', 'pipelineId', pipelineId)
            // verify required parameter 'revisionId' is not null or undefined
            assertParamExists('getCatalogPipelineRevision', 'revisionId', revisionId)
            const localVarPath = `/catalogs/{catalog_id}/pipelines/{pipeline_id}/revisions/{revision_id}`
                .replace(`{${"catalog_id"}}`, encodeURIComponent(String(catalogId)))
                .replace(`{${"pipeline_id"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"revision_id"}}`, encodeURIComponent(String(revisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List catalog pipeline revisions included in the steps of a given catalog pipeline pipeline revision
         * @param {string} catalogId Catalog ID
         * @param {string} pipelineId Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {Array<'variables' | 'outputs' | 'steps' | 'layout'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogPipelineRevisionPipelineRevisions: async (catalogId: string, pipelineId: string, revisionId: string, fields?: Array<'variables' | 'outputs' | 'steps' | 'layout'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogId' is not null or undefined
            assertParamExists('getCatalogPipelineRevisionPipelineRevisions', 'catalogId', catalogId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getCatalogPipelineRevisionPipelineRevisions', 'pipelineId', pipelineId)
            // verify required parameter 'revisionId' is not null or undefined
            assertParamExists('getCatalogPipelineRevisionPipelineRevisions', 'revisionId', revisionId)
            const localVarPath = `/catalogs/{catalog_id}/pipelines/{pipeline_id}/revisions/{revision_id}/revisions`
                .replace(`{${"catalog_id"}}`, encodeURIComponent(String(catalogId)))
                .replace(`{${"pipeline_id"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"revision_id"}}`, encodeURIComponent(String(revisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List catalog pipelines included in the steps of a given catalog pipeline revision
         * @param {string} catalogId Catalog ID
         * @param {string} pipelineId Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogPipelineRevisionPipelines: async (catalogId: string, pipelineId: string, revisionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogId' is not null or undefined
            assertParamExists('getCatalogPipelineRevisionPipelines', 'catalogId', catalogId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getCatalogPipelineRevisionPipelines', 'pipelineId', pipelineId)
            // verify required parameter 'revisionId' is not null or undefined
            assertParamExists('getCatalogPipelineRevisionPipelines', 'revisionId', revisionId)
            const localVarPath = `/catalogs/{catalog_id}/pipelines/{pipeline_id}/revisions/{revision_id}/pipelines`
                .replace(`{${"catalog_id"}}`, encodeURIComponent(String(catalogId)))
                .replace(`{${"pipeline_id"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"revision_id"}}`, encodeURIComponent(String(revisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get catalog pipeline versions
         * @param {string} catalogId Catalog ID
         * @param {string} pipelineId Pipeline ID
         * @param {Array<'variables' | 'outputs'>} [fields] Additional fields to return
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogPipelineRevisions: async (catalogId: string, pipelineId: string, fields?: Array<'variables' | 'outputs'>, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogId' is not null or undefined
            assertParamExists('getCatalogPipelineRevisions', 'catalogId', catalogId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getCatalogPipelineRevisions', 'pipelineId', pipelineId)
            const localVarPath = `/catalogs/{catalog_id}/pipelines/{pipeline_id}/revisions`
                .replace(`{${"catalog_id"}}`, encodeURIComponent(String(catalogId)))
                .replace(`{${"pipeline_id"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List catalog access requests
         * @param {string} organizationId Organization ID
         * @param {string} catalogId Catalog ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCatalogAccessRequests: async (organizationId: string, catalogId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listCatalogAccessRequests', 'organizationId', organizationId)
            // verify required parameter 'catalogId' is not null or undefined
            assertParamExists('listCatalogAccessRequests', 'catalogId', catalogId)
            const localVarPath = `/organizations/{organization_id}/catalogs/{catalog_id}/access_requests`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"catalog_id"}}`, encodeURIComponent(String(catalogId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organizations with access to the given catalog.
         * @param {string} organizationId Organization ID
         * @param {string} catalogId Catalog ID
         * @param {Array<'shared_organization'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCatalogOrganizationAccess: async (organizationId: string, catalogId: string, fields?: Array<'shared_organization'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listCatalogOrganizationAccess', 'organizationId', organizationId)
            // verify required parameter 'catalogId' is not null or undefined
            assertParamExists('listCatalogOrganizationAccess', 'catalogId', catalogId)
            const localVarPath = `/organizations/{organization_id}/catalogs/{catalog_id}/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"catalog_id"}}`, encodeURIComponent(String(catalogId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List catalog pipelines
         * @param {string} catalogId Catalog ID
         * @param {'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc'} [sort] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [search] 
         * @param {boolean} [pinned] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCatalogPipelines: async (catalogId: string, sort?: 'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc', limit?: number, offset?: number, search?: string, pinned?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogId' is not null or undefined
            assertParamExists('listCatalogPipelines', 'catalogId', catalogId)
            const localVarPath = `/catalogs/{catalog_id}/pipelines`
                .replace(`{${"catalog_id"}}`, encodeURIComponent(String(catalogId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (pinned !== undefined) {
                localVarQueryParameter['pinned'] = pinned;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List pending outgoing access requests for an organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationSharedCatalogAccessRequests: async (organizationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationSharedCatalogAccessRequests', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/catalogs/shared/access_requests`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List shared catalogs available to organization
         * @param {string} organizationId Owner Organization ID
         * @param {'all' | 'accessible'} scope Access scope of catalogs to return
         * @param {'name_asc' | 'name_desc'} [sort] 
         * @param {string} [search] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [ownerOrganizationId] Owner Organization ID
         * @param {Set<CatalogTags>} [tags] Catalog tags filter
         * @param {Array<'organization' | 'pending_access_request'>} [fields] Additional fields to return
         * @param {boolean} [draft] Include draft catalogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationSharedCatalogs: async (organizationId: string, scope: 'all' | 'accessible', sort?: 'name_asc' | 'name_desc', search?: string, limit?: number, offset?: number, ownerOrganizationId?: string, tags?: Set<CatalogTags>, fields?: Array<'organization' | 'pending_access_request'>, draft?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationSharedCatalogs', 'organizationId', organizationId)
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('listOrganizationSharedCatalogs', 'scope', scope)
            const localVarPath = `/organizations/{organization_id}/catalogs/shared`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ownerOrganizationId !== undefined) {
                localVarQueryParameter['owner_organization_id'] = ownerOrganizationId;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (draft !== undefined) {
                localVarQueryParameter['draft'] = draft;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organizations with publicly available catalogs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSharingCatalogsOrganizations: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/catalogs/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke an organization\'s access to a catalog.
         * @param {string} organizationId Organization ID
         * @param {string} catalogId Catalog ID
         * @param {string} sharedOrganizationId Shared Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCatalogAccess: async (organizationId: string, catalogId: string, sharedOrganizationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeCatalogAccess', 'organizationId', organizationId)
            // verify required parameter 'catalogId' is not null or undefined
            assertParamExists('removeCatalogAccess', 'catalogId', catalogId)
            // verify required parameter 'sharedOrganizationId' is not null or undefined
            assertParamExists('removeCatalogAccess', 'sharedOrganizationId', sharedOrganizationId)
            const localVarPath = `/organizations/{organization_id}/catalogs/{catalog_id}/access/{shared_organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"catalog_id"}}`, encodeURIComponent(String(catalogId)))
                .replace(`{${"shared_organization_id"}}`, encodeURIComponent(String(sharedOrganizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run catalog pipeline
         * @param {string} catalogId Catalog ID
         * @param {string} pipelineId Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {InlineObject9} inlineObject9 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runCatalogPipeline: async (catalogId: string, pipelineId: string, revisionId: string, inlineObject9: InlineObject9, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogId' is not null or undefined
            assertParamExists('runCatalogPipeline', 'catalogId', catalogId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('runCatalogPipeline', 'pipelineId', pipelineId)
            // verify required parameter 'revisionId' is not null or undefined
            assertParamExists('runCatalogPipeline', 'revisionId', revisionId)
            // verify required parameter 'inlineObject9' is not null or undefined
            assertParamExists('runCatalogPipeline', 'inlineObject9', inlineObject9)
            const localVarPath = `/catalogs/{catalog_id}/pipelines/{pipeline_id}/revisions/{revision_id}/run`
                .replace(`{${"catalog_id"}}`, encodeURIComponent(String(catalogId)))
                .replace(`{${"pipeline_id"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"revision_id"}}`, encodeURIComponent(String(revisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject9, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update catalog access request (approve or deny).
         * @param {string} organizationId Organization ID
         * @param {string} catalogId Catalog ID
         * @param {string} accessRequestId Access Request ID
         * @param {InlineObject17} inlineObject17 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCatalogAccessRequest: async (organizationId: string, catalogId: string, accessRequestId: string, inlineObject17: InlineObject17, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateCatalogAccessRequest', 'organizationId', organizationId)
            // verify required parameter 'catalogId' is not null or undefined
            assertParamExists('updateCatalogAccessRequest', 'catalogId', catalogId)
            // verify required parameter 'accessRequestId' is not null or undefined
            assertParamExists('updateCatalogAccessRequest', 'accessRequestId', accessRequestId)
            // verify required parameter 'inlineObject17' is not null or undefined
            assertParamExists('updateCatalogAccessRequest', 'inlineObject17', inlineObject17)
            const localVarPath = `/organizations/{organization_id}/catalogs/{catalog_id}/access_requests/{access_request_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"catalog_id"}}`, encodeURIComponent(String(catalogId)))
                .replace(`{${"access_request_id"}}`, encodeURIComponent(String(accessRequestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject17, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogsApi - functional programming interface
 * @export
 */
export const CatalogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CatalogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Clone catalog pipeline
         * @param {string} catalogId Catalog ID
         * @param {string} pipelineId Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {InlineObject8} inlineObject8 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneCatalogPipeline(catalogId: string, pipelineId: string, revisionId: string, inlineObject8: InlineObject8, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneCatalogPipeline(catalogId, pipelineId, revisionId, inlineObject8, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a catalog access request
         * @param {string} organizationId Organization ID
         * @param {string} catalogId Catalog ID
         * @param {InlineObject16} inlineObject16 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCatalogAccessRequest(organizationId: string, catalogId: string, inlineObject16: InlineObject16, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCatalogAccessRequest(organizationId, catalogId, inlineObject16, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get catalog
         * @param {string} catalogId Catalog ID
         * @param {Array<'organization'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCatalog(catalogId: string, fields?: Array<'organization'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCatalog(catalogId, fields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get catalog pipeline
         * @param {string} catalogId Catalog ID
         * @param {string} pipelineId Pipeline ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCatalogPipeline(catalogId: string, pipelineId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCatalogPipeline(catalogId, pipelineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get catalog pipeline revision
         * @param {string} catalogId Catalog ID
         * @param {string} pipelineId Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCatalogPipelineRevision(catalogId: string, pipelineId: string, revisionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineRevision>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCatalogPipelineRevision(catalogId, pipelineId, revisionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List catalog pipeline revisions included in the steps of a given catalog pipeline pipeline revision
         * @param {string} catalogId Catalog ID
         * @param {string} pipelineId Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {Array<'variables' | 'outputs' | 'steps' | 'layout'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCatalogPipelineRevisionPipelineRevisions(catalogId: string, pipelineId: string, revisionId: string, fields?: Array<'variables' | 'outputs' | 'steps' | 'layout'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCatalogPipelineRevisionPipelineRevisions(catalogId, pipelineId, revisionId, fields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List catalog pipelines included in the steps of a given catalog pipeline revision
         * @param {string} catalogId Catalog ID
         * @param {string} pipelineId Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCatalogPipelineRevisionPipelines(catalogId: string, pipelineId: string, revisionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCatalogPipelineRevisionPipelines(catalogId, pipelineId, revisionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get catalog pipeline versions
         * @param {string} catalogId Catalog ID
         * @param {string} pipelineId Pipeline ID
         * @param {Array<'variables' | 'outputs'>} [fields] Additional fields to return
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCatalogPipelineRevisions(catalogId: string, pipelineId: string, fields?: Array<'variables' | 'outputs'>, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCatalogPipelineRevisions(catalogId, pipelineId, fields, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List catalog access requests
         * @param {string} organizationId Organization ID
         * @param {string} catalogId Catalog ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCatalogAccessRequests(organizationId: string, catalogId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCatalogAccessRequests(organizationId, catalogId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List organizations with access to the given catalog.
         * @param {string} organizationId Organization ID
         * @param {string} catalogId Catalog ID
         * @param {Array<'shared_organization'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCatalogOrganizationAccess(organizationId: string, catalogId: string, fields?: Array<'shared_organization'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCatalogOrganizationAccess(organizationId, catalogId, fields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List catalog pipelines
         * @param {string} catalogId Catalog ID
         * @param {'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc'} [sort] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [search] 
         * @param {boolean} [pinned] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCatalogPipelines(catalogId: string, sort?: 'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc', limit?: number, offset?: number, search?: string, pinned?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCatalogPipelines(catalogId, sort, limit, offset, search, pinned, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List pending outgoing access requests for an organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationSharedCatalogAccessRequests(organizationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationSharedCatalogAccessRequests(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List shared catalogs available to organization
         * @param {string} organizationId Owner Organization ID
         * @param {'all' | 'accessible'} scope Access scope of catalogs to return
         * @param {'name_asc' | 'name_desc'} [sort] 
         * @param {string} [search] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [ownerOrganizationId] Owner Organization ID
         * @param {Set<CatalogTags>} [tags] Catalog tags filter
         * @param {Array<'organization' | 'pending_access_request'>} [fields] Additional fields to return
         * @param {boolean} [draft] Include draft catalogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationSharedCatalogs(organizationId: string, scope: 'all' | 'accessible', sort?: 'name_asc' | 'name_desc', search?: string, limit?: number, offset?: number, ownerOrganizationId?: string, tags?: Set<CatalogTags>, fields?: Array<'organization' | 'pending_access_request'>, draft?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationSharedCatalogs(organizationId, scope, sort, search, limit, offset, ownerOrganizationId, tags, fields, draft, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List organizations with publicly available catalogs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSharingCatalogsOrganizations(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSharingCatalogsOrganizations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Revoke an organization\'s access to a catalog.
         * @param {string} organizationId Organization ID
         * @param {string} catalogId Catalog ID
         * @param {string} sharedOrganizationId Shared Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeCatalogAccess(organizationId: string, catalogId: string, sharedOrganizationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeCatalogAccess(organizationId, catalogId, sharedOrganizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Run catalog pipeline
         * @param {string} catalogId Catalog ID
         * @param {string} pipelineId Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {InlineObject9} inlineObject9 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runCatalogPipeline(catalogId: string, pipelineId: string, revisionId: string, inlineObject9: InlineObject9, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse201>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runCatalogPipeline(catalogId, pipelineId, revisionId, inlineObject9, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update catalog access request (approve or deny).
         * @param {string} organizationId Organization ID
         * @param {string} catalogId Catalog ID
         * @param {string} accessRequestId Access Request ID
         * @param {InlineObject17} inlineObject17 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCatalogAccessRequest(organizationId: string, catalogId: string, accessRequestId: string, inlineObject17: InlineObject17, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCatalogAccessRequest(organizationId, catalogId, accessRequestId, inlineObject17, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CatalogsApi - factory interface
 * @export
 */
export const CatalogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CatalogsApiFp(configuration)
    return {
        /**
         * 
         * @summary Clone catalog pipeline
         * @param {string} catalogId Catalog ID
         * @param {string} pipelineId Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {InlineObject8} inlineObject8 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneCatalogPipeline(catalogId: string, pipelineId: string, revisionId: string, inlineObject8: InlineObject8, options?: any): AxiosPromise<InlineResponse2011> {
            return localVarFp.cloneCatalogPipeline(catalogId, pipelineId, revisionId, inlineObject8, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a catalog access request
         * @param {string} organizationId Organization ID
         * @param {string} catalogId Catalog ID
         * @param {InlineObject16} inlineObject16 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCatalogAccessRequest(organizationId: string, catalogId: string, inlineObject16: InlineObject16, options?: any): AxiosPromise<void> {
            return localVarFp.createCatalogAccessRequest(organizationId, catalogId, inlineObject16, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get catalog
         * @param {string} catalogId Catalog ID
         * @param {Array<'organization'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalog(catalogId: string, fields?: Array<'organization'>, options?: any): AxiosPromise<InlineResponse2009> {
            return localVarFp.getCatalog(catalogId, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get catalog pipeline
         * @param {string} catalogId Catalog ID
         * @param {string} pipelineId Pipeline ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogPipeline(catalogId: string, pipelineId: string, options?: any): AxiosPromise<Pipeline> {
            return localVarFp.getCatalogPipeline(catalogId, pipelineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get catalog pipeline revision
         * @param {string} catalogId Catalog ID
         * @param {string} pipelineId Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogPipelineRevision(catalogId: string, pipelineId: string, revisionId: string, options?: any): AxiosPromise<PipelineRevision> {
            return localVarFp.getCatalogPipelineRevision(catalogId, pipelineId, revisionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List catalog pipeline revisions included in the steps of a given catalog pipeline pipeline revision
         * @param {string} catalogId Catalog ID
         * @param {string} pipelineId Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {Array<'variables' | 'outputs' | 'steps' | 'layout'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogPipelineRevisionPipelineRevisions(catalogId: string, pipelineId: string, revisionId: string, fields?: Array<'variables' | 'outputs' | 'steps' | 'layout'>, options?: any): AxiosPromise<InlineResponse2008> {
            return localVarFp.getCatalogPipelineRevisionPipelineRevisions(catalogId, pipelineId, revisionId, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List catalog pipelines included in the steps of a given catalog pipeline revision
         * @param {string} catalogId Catalog ID
         * @param {string} pipelineId Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogPipelineRevisionPipelines(catalogId: string, pipelineId: string, revisionId: string, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.getCatalogPipelineRevisionPipelines(catalogId, pipelineId, revisionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get catalog pipeline versions
         * @param {string} catalogId Catalog ID
         * @param {string} pipelineId Pipeline ID
         * @param {Array<'variables' | 'outputs'>} [fields] Additional fields to return
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogPipelineRevisions(catalogId: string, pipelineId: string, fields?: Array<'variables' | 'outputs'>, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.getCatalogPipelineRevisions(catalogId, pipelineId, fields, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List catalog access requests
         * @param {string} organizationId Organization ID
         * @param {string} catalogId Catalog ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCatalogAccessRequests(organizationId: string, catalogId: string, options?: any): AxiosPromise<InlineResponse20016> {
            return localVarFp.listCatalogAccessRequests(organizationId, catalogId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organizations with access to the given catalog.
         * @param {string} organizationId Organization ID
         * @param {string} catalogId Catalog ID
         * @param {Array<'shared_organization'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCatalogOrganizationAccess(organizationId: string, catalogId: string, fields?: Array<'shared_organization'>, options?: any): AxiosPromise<InlineResponse20017> {
            return localVarFp.listCatalogOrganizationAccess(organizationId, catalogId, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List catalog pipelines
         * @param {string} catalogId Catalog ID
         * @param {'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc'} [sort] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [search] 
         * @param {boolean} [pinned] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCatalogPipelines(catalogId: string, sort?: 'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc', limit?: number, offset?: number, search?: string, pinned?: boolean, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.listCatalogPipelines(catalogId, sort, limit, offset, search, pinned, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List pending outgoing access requests for an organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationSharedCatalogAccessRequests(organizationId: string, options?: any): AxiosPromise<InlineResponse20016> {
            return localVarFp.listOrganizationSharedCatalogAccessRequests(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List shared catalogs available to organization
         * @param {string} organizationId Owner Organization ID
         * @param {'all' | 'accessible'} scope Access scope of catalogs to return
         * @param {'name_asc' | 'name_desc'} [sort] 
         * @param {string} [search] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [ownerOrganizationId] Owner Organization ID
         * @param {Set<CatalogTags>} [tags] Catalog tags filter
         * @param {Array<'organization' | 'pending_access_request'>} [fields] Additional fields to return
         * @param {boolean} [draft] Include draft catalogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationSharedCatalogs(organizationId: string, scope: 'all' | 'accessible', sort?: 'name_asc' | 'name_desc', search?: string, limit?: number, offset?: number, ownerOrganizationId?: string, tags?: Set<CatalogTags>, fields?: Array<'organization' | 'pending_access_request'>, draft?: boolean, options?: any): AxiosPromise<InlineResponse2009> {
            return localVarFp.listOrganizationSharedCatalogs(organizationId, scope, sort, search, limit, offset, ownerOrganizationId, tags, fields, draft, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organizations with publicly available catalogs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSharingCatalogsOrganizations(options?: any): AxiosPromise<InlineResponse20011> {
            return localVarFp.listSharingCatalogsOrganizations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke an organization\'s access to a catalog.
         * @param {string} organizationId Organization ID
         * @param {string} catalogId Catalog ID
         * @param {string} sharedOrganizationId Shared Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCatalogAccess(organizationId: string, catalogId: string, sharedOrganizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeCatalogAccess(organizationId, catalogId, sharedOrganizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Run catalog pipeline
         * @param {string} catalogId Catalog ID
         * @param {string} pipelineId Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {InlineObject9} inlineObject9 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runCatalogPipeline(catalogId: string, pipelineId: string, revisionId: string, inlineObject9: InlineObject9, options?: any): AxiosPromise<InlineResponse201> {
            return localVarFp.runCatalogPipeline(catalogId, pipelineId, revisionId, inlineObject9, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update catalog access request (approve or deny).
         * @param {string} organizationId Organization ID
         * @param {string} catalogId Catalog ID
         * @param {string} accessRequestId Access Request ID
         * @param {InlineObject17} inlineObject17 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCatalogAccessRequest(organizationId: string, catalogId: string, accessRequestId: string, inlineObject17: InlineObject17, options?: any): AxiosPromise<void> {
            return localVarFp.updateCatalogAccessRequest(organizationId, catalogId, accessRequestId, inlineObject17, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CatalogsApi - object-oriented interface
 * @export
 * @class CatalogsApi
 * @extends {BaseAPI}
 */
export class CatalogsApi extends BaseAPI {
    /**
     * 
     * @summary Clone catalog pipeline
     * @param {string} catalogId Catalog ID
     * @param {string} pipelineId Pipeline ID
     * @param {string} revisionId Pipeline revision ID
     * @param {InlineObject8} inlineObject8 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public cloneCatalogPipeline(catalogId: string, pipelineId: string, revisionId: string, inlineObject8: InlineObject8, options?: any) {
        return CatalogsApiFp(this.configuration).cloneCatalogPipeline(catalogId, pipelineId, revisionId, inlineObject8, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a catalog access request
     * @param {string} organizationId Organization ID
     * @param {string} catalogId Catalog ID
     * @param {InlineObject16} inlineObject16 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public createCatalogAccessRequest(organizationId: string, catalogId: string, inlineObject16: InlineObject16, options?: any) {
        return CatalogsApiFp(this.configuration).createCatalogAccessRequest(organizationId, catalogId, inlineObject16, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get catalog
     * @param {string} catalogId Catalog ID
     * @param {Array<'organization'>} [fields] Additional fields to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public getCatalog(catalogId: string, fields?: Array<'organization'>, options?: any) {
        return CatalogsApiFp(this.configuration).getCatalog(catalogId, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get catalog pipeline
     * @param {string} catalogId Catalog ID
     * @param {string} pipelineId Pipeline ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public getCatalogPipeline(catalogId: string, pipelineId: string, options?: any) {
        return CatalogsApiFp(this.configuration).getCatalogPipeline(catalogId, pipelineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get catalog pipeline revision
     * @param {string} catalogId Catalog ID
     * @param {string} pipelineId Pipeline ID
     * @param {string} revisionId Pipeline revision ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public getCatalogPipelineRevision(catalogId: string, pipelineId: string, revisionId: string, options?: any) {
        return CatalogsApiFp(this.configuration).getCatalogPipelineRevision(catalogId, pipelineId, revisionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List catalog pipeline revisions included in the steps of a given catalog pipeline pipeline revision
     * @param {string} catalogId Catalog ID
     * @param {string} pipelineId Pipeline ID
     * @param {string} revisionId Pipeline revision ID
     * @param {Array<'variables' | 'outputs' | 'steps' | 'layout'>} [fields] Additional fields to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public getCatalogPipelineRevisionPipelineRevisions(catalogId: string, pipelineId: string, revisionId: string, fields?: Array<'variables' | 'outputs' | 'steps' | 'layout'>, options?: any) {
        return CatalogsApiFp(this.configuration).getCatalogPipelineRevisionPipelineRevisions(catalogId, pipelineId, revisionId, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List catalog pipelines included in the steps of a given catalog pipeline revision
     * @param {string} catalogId Catalog ID
     * @param {string} pipelineId Pipeline ID
     * @param {string} revisionId Pipeline revision ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public getCatalogPipelineRevisionPipelines(catalogId: string, pipelineId: string, revisionId: string, options?: any) {
        return CatalogsApiFp(this.configuration).getCatalogPipelineRevisionPipelines(catalogId, pipelineId, revisionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get catalog pipeline versions
     * @param {string} catalogId Catalog ID
     * @param {string} pipelineId Pipeline ID
     * @param {Array<'variables' | 'outputs'>} [fields] Additional fields to return
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public getCatalogPipelineRevisions(catalogId: string, pipelineId: string, fields?: Array<'variables' | 'outputs'>, limit?: number, offset?: number, options?: any) {
        return CatalogsApiFp(this.configuration).getCatalogPipelineRevisions(catalogId, pipelineId, fields, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List catalog access requests
     * @param {string} organizationId Organization ID
     * @param {string} catalogId Catalog ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public listCatalogAccessRequests(organizationId: string, catalogId: string, options?: any) {
        return CatalogsApiFp(this.configuration).listCatalogAccessRequests(organizationId, catalogId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organizations with access to the given catalog.
     * @param {string} organizationId Organization ID
     * @param {string} catalogId Catalog ID
     * @param {Array<'shared_organization'>} [fields] Additional fields to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public listCatalogOrganizationAccess(organizationId: string, catalogId: string, fields?: Array<'shared_organization'>, options?: any) {
        return CatalogsApiFp(this.configuration).listCatalogOrganizationAccess(organizationId, catalogId, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List catalog pipelines
     * @param {string} catalogId Catalog ID
     * @param {'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc'} [sort] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [search] 
     * @param {boolean} [pinned] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public listCatalogPipelines(catalogId: string, sort?: 'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc', limit?: number, offset?: number, search?: string, pinned?: boolean, options?: any) {
        return CatalogsApiFp(this.configuration).listCatalogPipelines(catalogId, sort, limit, offset, search, pinned, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List pending outgoing access requests for an organization
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public listOrganizationSharedCatalogAccessRequests(organizationId: string, options?: any) {
        return CatalogsApiFp(this.configuration).listOrganizationSharedCatalogAccessRequests(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List shared catalogs available to organization
     * @param {string} organizationId Owner Organization ID
     * @param {'all' | 'accessible'} scope Access scope of catalogs to return
     * @param {'name_asc' | 'name_desc'} [sort] 
     * @param {string} [search] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [ownerOrganizationId] Owner Organization ID
     * @param {Set<CatalogTags>} [tags] Catalog tags filter
     * @param {Array<'organization' | 'pending_access_request'>} [fields] Additional fields to return
     * @param {boolean} [draft] Include draft catalogs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public listOrganizationSharedCatalogs(organizationId: string, scope: 'all' | 'accessible', sort?: 'name_asc' | 'name_desc', search?: string, limit?: number, offset?: number, ownerOrganizationId?: string, tags?: Set<CatalogTags>, fields?: Array<'organization' | 'pending_access_request'>, draft?: boolean, options?: any) {
        return CatalogsApiFp(this.configuration).listOrganizationSharedCatalogs(organizationId, scope, sort, search, limit, offset, ownerOrganizationId, tags, fields, draft, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organizations with publicly available catalogs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public listSharingCatalogsOrganizations(options?: any) {
        return CatalogsApiFp(this.configuration).listSharingCatalogsOrganizations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke an organization\'s access to a catalog.
     * @param {string} organizationId Organization ID
     * @param {string} catalogId Catalog ID
     * @param {string} sharedOrganizationId Shared Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public removeCatalogAccess(organizationId: string, catalogId: string, sharedOrganizationId: string, options?: any) {
        return CatalogsApiFp(this.configuration).removeCatalogAccess(organizationId, catalogId, sharedOrganizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Run catalog pipeline
     * @param {string} catalogId Catalog ID
     * @param {string} pipelineId Pipeline ID
     * @param {string} revisionId Pipeline revision ID
     * @param {InlineObject9} inlineObject9 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public runCatalogPipeline(catalogId: string, pipelineId: string, revisionId: string, inlineObject9: InlineObject9, options?: any) {
        return CatalogsApiFp(this.configuration).runCatalogPipeline(catalogId, pipelineId, revisionId, inlineObject9, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update catalog access request (approve or deny).
     * @param {string} organizationId Organization ID
     * @param {string} catalogId Catalog ID
     * @param {string} accessRequestId Access Request ID
     * @param {InlineObject17} inlineObject17 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public updateCatalogAccessRequest(organizationId: string, catalogId: string, accessRequestId: string, inlineObject17: InlineObject17, options?: any) {
        return CatalogsApiFp(this.configuration).updateCatalogAccessRequest(organizationId, catalogId, accessRequestId, inlineObject17, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CredentialsApi - axios parameter creator
 * @export
 */
export const CredentialsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create credential
         * @param {string} projectId Project ID
         * @param {Credential} credential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredential: async (projectId: string, credential: Credential, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createCredential', 'projectId', projectId)
            // verify required parameter 'credential' is not null or undefined
            assertParamExists('createCredential', 'credential', credential)
            const localVarPath = `/projects/{project_id}/credentials`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(credential, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete credential
         * @param {string} projectId Project ID
         * @param {string} id Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential: async (projectId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteCredential', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCredential', 'id', id)
            const localVarPath = `/projects/{project_id}/credentials/{_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get credential
         * @param {string} projectId Project ID
         * @param {string} id Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredential: async (projectId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getCredential', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCredential', 'id', id)
            const localVarPath = `/projects/{project_id}/credentials/{_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List credentials
         * @param {string} projectId Project ID
         * @param {Array<'generic' | 'username_password' | 'ssh_key' | 'bearer_token' | 'api_token' | 'azure_service_principal' | 'google_service_account' | 'aws_access_key' | 'vault_app_role' | 'cis_license_bundle'>} [type] Credential types filter
         * @param {'created_asc' | 'created_desc'} [sort] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials: async (projectId: string, type?: Array<'generic' | 'username_password' | 'ssh_key' | 'bearer_token' | 'api_token' | 'azure_service_principal' | 'google_service_account' | 'aws_access_key' | 'vault_app_role' | 'cis_license_bundle'>, sort?: 'created_asc' | 'created_desc', offset?: number, limit?: number, search?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listCredentials', 'projectId', projectId)
            const localVarPath = `/projects/{project_id}/credentials`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type) {
                localVarQueryParameter['type'] = type;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update credential
         * @param {string} projectId Project ID
         * @param {string} id Credential ID
         * @param {InlineObject12} inlineObject12 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential: async (projectId: string, id: string, inlineObject12: InlineObject12, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateCredential', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCredential', 'id', id)
            // verify required parameter 'inlineObject12' is not null or undefined
            assertParamExists('updateCredential', 'inlineObject12', inlineObject12)
            const localVarPath = `/projects/{project_id}/credentials/{_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject12, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CredentialsApi - functional programming interface
 * @export
 */
export const CredentialsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CredentialsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create credential
         * @param {string} projectId Project ID
         * @param {Credential} credential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCredential(projectId: string, credential: Credential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse201>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCredential(projectId, credential, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete credential
         * @param {string} projectId Project ID
         * @param {string} id Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCredential(projectId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCredential(projectId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get credential
         * @param {string} projectId Project ID
         * @param {string} id Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCredential(projectId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCredential(projectId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List credentials
         * @param {string} projectId Project ID
         * @param {Array<'generic' | 'username_password' | 'ssh_key' | 'bearer_token' | 'api_token' | 'azure_service_principal' | 'google_service_account' | 'aws_access_key' | 'vault_app_role' | 'cis_license_bundle'>} [type] Credential types filter
         * @param {'created_asc' | 'created_desc'} [sort] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCredentials(projectId: string, type?: Array<'generic' | 'username_password' | 'ssh_key' | 'bearer_token' | 'api_token' | 'azure_service_principal' | 'google_service_account' | 'aws_access_key' | 'vault_app_role' | 'cis_license_bundle'>, sort?: 'created_asc' | 'created_desc', offset?: number, limit?: number, search?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20010>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCredentials(projectId, type, sort, offset, limit, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update credential
         * @param {string} projectId Project ID
         * @param {string} id Credential ID
         * @param {InlineObject12} inlineObject12 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCredential(projectId: string, id: string, inlineObject12: InlineObject12, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse201>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCredential(projectId, id, inlineObject12, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CredentialsApi - factory interface
 * @export
 */
export const CredentialsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CredentialsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create credential
         * @param {string} projectId Project ID
         * @param {Credential} credential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredential(projectId: string, credential: Credential, options?: any): AxiosPromise<InlineResponse201> {
            return localVarFp.createCredential(projectId, credential, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete credential
         * @param {string} projectId Project ID
         * @param {string} id Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential(projectId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCredential(projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get credential
         * @param {string} projectId Project ID
         * @param {string} id Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredential(projectId: string, id: string, options?: any): AxiosPromise<Credential> {
            return localVarFp.getCredential(projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List credentials
         * @param {string} projectId Project ID
         * @param {Array<'generic' | 'username_password' | 'ssh_key' | 'bearer_token' | 'api_token' | 'azure_service_principal' | 'google_service_account' | 'aws_access_key' | 'vault_app_role' | 'cis_license_bundle'>} [type] Credential types filter
         * @param {'created_asc' | 'created_desc'} [sort] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials(projectId: string, type?: Array<'generic' | 'username_password' | 'ssh_key' | 'bearer_token' | 'api_token' | 'azure_service_principal' | 'google_service_account' | 'aws_access_key' | 'vault_app_role' | 'cis_license_bundle'>, sort?: 'created_asc' | 'created_desc', offset?: number, limit?: number, search?: string, options?: any): AxiosPromise<InlineResponse20010> {
            return localVarFp.listCredentials(projectId, type, sort, offset, limit, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update credential
         * @param {string} projectId Project ID
         * @param {string} id Credential ID
         * @param {InlineObject12} inlineObject12 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential(projectId: string, id: string, inlineObject12: InlineObject12, options?: any): AxiosPromise<InlineResponse201> {
            return localVarFp.updateCredential(projectId, id, inlineObject12, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CredentialsApi - object-oriented interface
 * @export
 * @class CredentialsApi
 * @extends {BaseAPI}
 */
export class CredentialsApi extends BaseAPI {
    /**
     * 
     * @summary Create credential
     * @param {string} projectId Project ID
     * @param {Credential} credential 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public createCredential(projectId: string, credential: Credential, options?: any) {
        return CredentialsApiFp(this.configuration).createCredential(projectId, credential, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete credential
     * @param {string} projectId Project ID
     * @param {string} id Credential ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public deleteCredential(projectId: string, id: string, options?: any) {
        return CredentialsApiFp(this.configuration).deleteCredential(projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get credential
     * @param {string} projectId Project ID
     * @param {string} id Credential ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public getCredential(projectId: string, id: string, options?: any) {
        return CredentialsApiFp(this.configuration).getCredential(projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List credentials
     * @param {string} projectId Project ID
     * @param {Array<'generic' | 'username_password' | 'ssh_key' | 'bearer_token' | 'api_token' | 'azure_service_principal' | 'google_service_account' | 'aws_access_key' | 'vault_app_role' | 'cis_license_bundle'>} [type] Credential types filter
     * @param {'created_asc' | 'created_desc'} [sort] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public listCredentials(projectId: string, type?: Array<'generic' | 'username_password' | 'ssh_key' | 'bearer_token' | 'api_token' | 'azure_service_principal' | 'google_service_account' | 'aws_access_key' | 'vault_app_role' | 'cis_license_bundle'>, sort?: 'created_asc' | 'created_desc', offset?: number, limit?: number, search?: string, options?: any) {
        return CredentialsApiFp(this.configuration).listCredentials(projectId, type, sort, offset, limit, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update credential
     * @param {string} projectId Project ID
     * @param {string} id Credential ID
     * @param {InlineObject12} inlineObject12 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public updateCredential(projectId: string, id: string, inlineObject12: InlineObject12, options?: any) {
        return CredentialsApiFp(this.configuration).updateCredential(projectId, id, inlineObject12, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JobsApi - axios parameter creator
 * @export
 */
export const JobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create job
         * @param {string} projectId Project ID
         * @param {Job} job 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJob: async (projectId: string, job: Job, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createJob', 'projectId', projectId)
            // verify required parameter 'job' is not null or undefined
            assertParamExists('createJob', 'job', job)
            const localVarPath = `/projects/{project_id}/jobs`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(job, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete job
         * @param {string} projectId Project ID
         * @param {string} id Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob: async (projectId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteJob', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteJob', 'id', id)
            const localVarPath = `/projects/{project_id}/jobs/{_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get job
         * @param {string} projectId Project ID
         * @param {string} id Job ID
         * @param {Array<'pipeline' | 'pipeline_revision' | 'webhook_token'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob: async (projectId: string, id: string, fields?: Array<'pipeline' | 'pipeline_revision' | 'webhook_token'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getJob', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getJob', 'id', id)
            const localVarPath = `/projects/{project_id}/jobs/{_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List jobs
         * @param {string} projectId Project ID
         * @param {'created_asc' | 'created_desc' | 'last_run_asc' | 'last_run_desc'} [sort] Sort
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<'pipeline' | 'pipeline_revision'>} [fields] Additional fields to return
         * @param {string} [search] 
         * @param {boolean} [pinned] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs: async (projectId: string, sort?: 'created_asc' | 'created_desc' | 'last_run_asc' | 'last_run_desc', limit?: number, offset?: number, fields?: Array<'pipeline' | 'pipeline_revision'>, search?: string, pinned?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listJobs', 'projectId', projectId)
            const localVarPath = `/projects/{project_id}/jobs`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (pinned !== undefined) {
                localVarQueryParameter['pinned'] = pinned;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regenerate job webhook token.
         * @param {string} projectId Project ID
         * @param {string} id Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateJobToken: async (projectId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('regenerateJobToken', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('regenerateJobToken', 'id', id)
            const localVarPath = `/projects/{project_id}/jobs/{_id}/webhook/token`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run job
         * @param {string} projectId Project ID
         * @param {string} id Job ID
         * @param {InlineObject13} inlineObject13 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runJob: async (projectId: string, id: string, inlineObject13: InlineObject13, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('runJob', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('runJob', 'id', id)
            // verify required parameter 'inlineObject13' is not null or undefined
            assertParamExists('runJob', 'inlineObject13', inlineObject13)
            const localVarPath = `/projects/{project_id}/jobs/{_id}/run`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject13, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update job
         * @param {string} projectId Project ID
         * @param {string} id Job ID
         * @param {Job} job 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJob: async (projectId: string, id: string, job: Job, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateJob', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateJob', 'id', id)
            // verify required parameter 'job' is not null or undefined
            assertParamExists('updateJob', 'job', job)
            const localVarPath = `/projects/{project_id}/jobs/{_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(job, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create job
         * @param {string} projectId Project ID
         * @param {Job} job 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJob(projectId: string, job: Job, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse201>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJob(projectId, job, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete job
         * @param {string} projectId Project ID
         * @param {string} id Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJob(projectId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJob(projectId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get job
         * @param {string} projectId Project ID
         * @param {string} id Job ID
         * @param {Array<'pipeline' | 'pipeline_revision' | 'webhook_token'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJob(projectId: string, id: string, fields?: Array<'pipeline' | 'pipeline_revision' | 'webhook_token'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJob(projectId, id, fields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List jobs
         * @param {string} projectId Project ID
         * @param {'created_asc' | 'created_desc' | 'last_run_asc' | 'last_run_desc'} [sort] Sort
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<'pipeline' | 'pipeline_revision'>} [fields] Additional fields to return
         * @param {string} [search] 
         * @param {boolean} [pinned] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobs(projectId: string, sort?: 'created_asc' | 'created_desc' | 'last_run_asc' | 'last_run_desc', limit?: number, offset?: number, fields?: Array<'pipeline' | 'pipeline_revision'>, search?: string, pinned?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobs(projectId, sort, limit, offset, fields, search, pinned, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Regenerate job webhook token.
         * @param {string} projectId Project ID
         * @param {string} id Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regenerateJobToken(projectId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regenerateJobToken(projectId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Run job
         * @param {string} projectId Project ID
         * @param {string} id Job ID
         * @param {InlineObject13} inlineObject13 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runJob(projectId: string, id: string, inlineObject13: InlineObject13, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse201>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runJob(projectId, id, inlineObject13, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update job
         * @param {string} projectId Project ID
         * @param {string} id Job ID
         * @param {Job} job 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateJob(projectId: string, id: string, job: Job, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateJob(projectId, id, job, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobsApi - factory interface
 * @export
 */
export const JobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create job
         * @param {string} projectId Project ID
         * @param {Job} job 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJob(projectId: string, job: Job, options?: any): AxiosPromise<InlineResponse201> {
            return localVarFp.createJob(projectId, job, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete job
         * @param {string} projectId Project ID
         * @param {string} id Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob(projectId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteJob(projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get job
         * @param {string} projectId Project ID
         * @param {string} id Job ID
         * @param {Array<'pipeline' | 'pipeline_revision' | 'webhook_token'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(projectId: string, id: string, fields?: Array<'pipeline' | 'pipeline_revision' | 'webhook_token'>, options?: any): AxiosPromise<Job> {
            return localVarFp.getJob(projectId, id, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List jobs
         * @param {string} projectId Project ID
         * @param {'created_asc' | 'created_desc' | 'last_run_asc' | 'last_run_desc'} [sort] Sort
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<'pipeline' | 'pipeline_revision'>} [fields] Additional fields to return
         * @param {string} [search] 
         * @param {boolean} [pinned] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs(projectId: string, sort?: 'created_asc' | 'created_desc' | 'last_run_asc' | 'last_run_desc', limit?: number, offset?: number, fields?: Array<'pipeline' | 'pipeline_revision'>, search?: string, pinned?: boolean, options?: any): AxiosPromise<InlineResponse20012> {
            return localVarFp.listJobs(projectId, sort, limit, offset, fields, search, pinned, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Regenerate job webhook token.
         * @param {string} projectId Project ID
         * @param {string} id Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateJobToken(projectId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.regenerateJobToken(projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Run job
         * @param {string} projectId Project ID
         * @param {string} id Job ID
         * @param {InlineObject13} inlineObject13 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runJob(projectId: string, id: string, inlineObject13: InlineObject13, options?: any): AxiosPromise<InlineResponse201> {
            return localVarFp.runJob(projectId, id, inlineObject13, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update job
         * @param {string} projectId Project ID
         * @param {string} id Job ID
         * @param {Job} job 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJob(projectId: string, id: string, job: Job, options?: any): AxiosPromise<void> {
            return localVarFp.updateJob(projectId, id, job, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobsApi - object-oriented interface
 * @export
 * @class JobsApi
 * @extends {BaseAPI}
 */
export class JobsApi extends BaseAPI {
    /**
     * 
     * @summary Create job
     * @param {string} projectId Project ID
     * @param {Job} job 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public createJob(projectId: string, job: Job, options?: any) {
        return JobsApiFp(this.configuration).createJob(projectId, job, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete job
     * @param {string} projectId Project ID
     * @param {string} id Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public deleteJob(projectId: string, id: string, options?: any) {
        return JobsApiFp(this.configuration).deleteJob(projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get job
     * @param {string} projectId Project ID
     * @param {string} id Job ID
     * @param {Array<'pipeline' | 'pipeline_revision' | 'webhook_token'>} [fields] Additional fields to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJob(projectId: string, id: string, fields?: Array<'pipeline' | 'pipeline_revision' | 'webhook_token'>, options?: any) {
        return JobsApiFp(this.configuration).getJob(projectId, id, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List jobs
     * @param {string} projectId Project ID
     * @param {'created_asc' | 'created_desc' | 'last_run_asc' | 'last_run_desc'} [sort] Sort
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {Array<'pipeline' | 'pipeline_revision'>} [fields] Additional fields to return
     * @param {string} [search] 
     * @param {boolean} [pinned] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public listJobs(projectId: string, sort?: 'created_asc' | 'created_desc' | 'last_run_asc' | 'last_run_desc', limit?: number, offset?: number, fields?: Array<'pipeline' | 'pipeline_revision'>, search?: string, pinned?: boolean, options?: any) {
        return JobsApiFp(this.configuration).listJobs(projectId, sort, limit, offset, fields, search, pinned, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Regenerate job webhook token.
     * @param {string} projectId Project ID
     * @param {string} id Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public regenerateJobToken(projectId: string, id: string, options?: any) {
        return JobsApiFp(this.configuration).regenerateJobToken(projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Run job
     * @param {string} projectId Project ID
     * @param {string} id Job ID
     * @param {InlineObject13} inlineObject13 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public runJob(projectId: string, id: string, inlineObject13: InlineObject13, options?: any) {
        return JobsApiFp(this.configuration).runJob(projectId, id, inlineObject13, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update job
     * @param {string} projectId Project ID
     * @param {string} id Job ID
     * @param {Job} job 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public updateJob(projectId: string, id: string, job: Job, options?: any) {
        return JobsApiFp(this.configuration).updateJob(projectId, id, job, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
export const OrganizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add organization notification channel
         * @param {string} organizationId Organization ID
         * @param {NotificationChannel} notificationChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationNotificationChannel: async (organizationId: string, notificationChannel: NotificationChannel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrganizationNotificationChannel', 'organizationId', organizationId)
            // verify required parameter 'notificationChannel' is not null or undefined
            assertParamExists('addOrganizationNotificationChannel', 'notificationChannel', notificationChannel)
            const localVarPath = `/organizations/{organization_id}/notification_channels`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationChannel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization
         * @param {string} organizationId Organization ID
         * @param {Array<'notification_channels'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: async (organizationId: string, fields?: Array<'notification_channels'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganization', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove organization notification channel
         * @param {string} organizationId Organization ID
         * @param {string} notificationChannelId Notification Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrganizationNotificationChannel: async (organizationId: string, notificationChannelId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeOrganizationNotificationChannel', 'organizationId', organizationId)
            // verify required parameter 'notificationChannelId' is not null or undefined
            assertParamExists('removeOrganizationNotificationChannel', 'notificationChannelId', notificationChannelId)
            const localVarPath = `/organizations/{organization_id}/notification_channels/{notification_channel_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"notification_channel_id"}}`, encodeURIComponent(String(notificationChannelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update organization
         * @param {string} organizationId Organization ID
         * @param {Organization} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization: async (organizationId: string, organization: Organization, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganization', 'organizationId', organizationId)
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('updateOrganization', 'organization', organization)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update organization notification channel
         * @param {string} organizationId Organization ID
         * @param {string} notificationChannelId Notification Channel ID
         * @param {NotificationChannel} notificationChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationNotificationChannel: async (organizationId: string, notificationChannelId: string, notificationChannel: NotificationChannel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganizationNotificationChannel', 'organizationId', organizationId)
            // verify required parameter 'notificationChannelId' is not null or undefined
            assertParamExists('updateOrganizationNotificationChannel', 'notificationChannelId', notificationChannelId)
            // verify required parameter 'notificationChannel' is not null or undefined
            assertParamExists('updateOrganizationNotificationChannel', 'notificationChannel', notificationChannel)
            const localVarPath = `/organizations/{organization_id}/notification_channels/{notification_channel_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"notification_channel_id"}}`, encodeURIComponent(String(notificationChannelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationChannel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add organization notification channel
         * @param {string} organizationId Organization ID
         * @param {NotificationChannel} notificationChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrganizationNotificationChannel(organizationId: string, notificationChannel: NotificationChannel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrganizationNotificationChannel(organizationId, notificationChannel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization
         * @param {string} organizationId Organization ID
         * @param {Array<'notification_channels'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganization(organizationId: string, fields?: Array<'notification_channels'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganization(organizationId, fields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizations(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove organization notification channel
         * @param {string} organizationId Organization ID
         * @param {string} notificationChannelId Notification Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOrganizationNotificationChannel(organizationId: string, notificationChannelId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeOrganizationNotificationChannel(organizationId, notificationChannelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update organization
         * @param {string} organizationId Organization ID
         * @param {Organization} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganization(organizationId: string, organization: Organization, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganization(organizationId, organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update organization notification channel
         * @param {string} organizationId Organization ID
         * @param {string} notificationChannelId Notification Channel ID
         * @param {NotificationChannel} notificationChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationNotificationChannel(organizationId: string, notificationChannelId: string, notificationChannel: NotificationChannel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationNotificationChannel(organizationId, notificationChannelId, notificationChannel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add organization notification channel
         * @param {string} organizationId Organization ID
         * @param {NotificationChannel} notificationChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationNotificationChannel(organizationId: string, notificationChannel: NotificationChannel, options?: any): AxiosPromise<void> {
            return localVarFp.addOrganizationNotificationChannel(organizationId, notificationChannel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization
         * @param {string} organizationId Organization ID
         * @param {Array<'notification_channels'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(organizationId: string, fields?: Array<'notification_channels'>, options?: any): AxiosPromise<Organization> {
            return localVarFp.getOrganization(organizationId, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations(options?: any): AxiosPromise<InlineResponse20015> {
            return localVarFp.listOrganizations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove organization notification channel
         * @param {string} organizationId Organization ID
         * @param {string} notificationChannelId Notification Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrganizationNotificationChannel(organizationId: string, notificationChannelId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeOrganizationNotificationChannel(organizationId, notificationChannelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update organization
         * @param {string} organizationId Organization ID
         * @param {Organization} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(organizationId: string, organization: Organization, options?: any): AxiosPromise<Organization> {
            return localVarFp.updateOrganization(organizationId, organization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update organization notification channel
         * @param {string} organizationId Organization ID
         * @param {string} notificationChannelId Notification Channel ID
         * @param {NotificationChannel} notificationChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationNotificationChannel(organizationId: string, notificationChannelId: string, notificationChannel: NotificationChannel, options?: any): AxiosPromise<void> {
            return localVarFp.updateOrganizationNotificationChannel(organizationId, notificationChannelId, notificationChannel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * 
     * @summary Add organization notification channel
     * @param {string} organizationId Organization ID
     * @param {NotificationChannel} notificationChannel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public addOrganizationNotificationChannel(organizationId: string, notificationChannel: NotificationChannel, options?: any) {
        return OrganizationsApiFp(this.configuration).addOrganizationNotificationChannel(organizationId, notificationChannel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization
     * @param {string} organizationId Organization ID
     * @param {Array<'notification_channels'>} [fields] Additional fields to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganization(organizationId: string, fields?: Array<'notification_channels'>, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganization(organizationId, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrganizations(options?: any) {
        return OrganizationsApiFp(this.configuration).listOrganizations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove organization notification channel
     * @param {string} organizationId Organization ID
     * @param {string} notificationChannelId Notification Channel ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public removeOrganizationNotificationChannel(organizationId: string, notificationChannelId: string, options?: any) {
        return OrganizationsApiFp(this.configuration).removeOrganizationNotificationChannel(organizationId, notificationChannelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update organization
     * @param {string} organizationId Organization ID
     * @param {Organization} organization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public updateOrganization(organizationId: string, organization: Organization, options?: any) {
        return OrganizationsApiFp(this.configuration).updateOrganization(organizationId, organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update organization notification channel
     * @param {string} organizationId Organization ID
     * @param {string} notificationChannelId Notification Channel ID
     * @param {NotificationChannel} notificationChannel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public updateOrganizationNotificationChannel(organizationId: string, notificationChannelId: string, notificationChannel: NotificationChannel, options?: any) {
        return OrganizationsApiFp(this.configuration).updateOrganizationNotificationChannel(organizationId, notificationChannelId, notificationChannel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PipelinesApi - axios parameter creator
 * @export
 */
export const PipelinesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clone pipeline
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {InlineObject10} inlineObject10 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clonePipeline: async (projectId: string, id: string, revisionId: string, inlineObject10: InlineObject10, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('clonePipeline', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clonePipeline', 'id', id)
            // verify required parameter 'revisionId' is not null or undefined
            assertParamExists('clonePipeline', 'revisionId', revisionId)
            // verify required parameter 'inlineObject10' is not null or undefined
            assertParamExists('clonePipeline', 'inlineObject10', inlineObject10)
            const localVarPath = `/projects/{project_id}/pipelines/{_id}/revisions/{revision_id}/clone`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"revision_id"}}`, encodeURIComponent(String(revisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject10, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create pipeline
         * @param {string} projectId Project ID
         * @param {Pipeline} pipeline 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipeline: async (projectId: string, pipeline: Pipeline, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createPipeline', 'projectId', projectId)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('createPipeline', 'pipeline', pipeline)
            const localVarPath = `/projects/{project_id}/pipelines`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipeline, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a pipeline revision
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {PipelineRevision} pipelineRevision 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipelineRevision: async (projectId: string, id: string, pipelineRevision: PipelineRevision, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createPipelineRevision', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPipelineRevision', 'id', id)
            // verify required parameter 'pipelineRevision' is not null or undefined
            assertParamExists('createPipelineRevision', 'pipelineRevision', pipelineRevision)
            const localVarPath = `/projects/{project_id}/pipelines/{_id}/revisions`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipelineRevision, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete pipeline
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipeline: async (projectId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deletePipeline', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePipeline', 'id', id)
            const localVarPath = `/projects/{project_id}/pipelines/{_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get pipeline
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipeline: async (projectId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getPipeline', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPipeline', 'id', id)
            const localVarPath = `/projects/{project_id}/pipelines/{_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get pipeline revision
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRevision: async (projectId: string, id: string, revisionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getPipelineRevision', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPipelineRevision', 'id', id)
            // verify required parameter 'revisionId' is not null or undefined
            assertParamExists('getPipelineRevision', 'revisionId', revisionId)
            const localVarPath = `/projects/{project_id}/pipelines/{_id}/revisions/{revision_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"revision_id"}}`, encodeURIComponent(String(revisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List pipeline revisions included in the steps of a given pipeline revision
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {string} revisionId Revision revision ID
         * @param {Array<'variables' | 'outputs' | 'steps' | 'layout'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRevisionPipelineRevisions: async (projectId: string, id: string, revisionId: string, fields?: Array<'variables' | 'outputs' | 'steps' | 'layout'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getPipelineRevisionPipelineRevisions', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPipelineRevisionPipelineRevisions', 'id', id)
            // verify required parameter 'revisionId' is not null or undefined
            assertParamExists('getPipelineRevisionPipelineRevisions', 'revisionId', revisionId)
            const localVarPath = `/projects/{project_id}/pipelines/{_id}/revisions/{revision_id}/revisions`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"revision_id"}}`, encodeURIComponent(String(revisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List pipelines included in the steps of a given pipeline revision
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {string} revisionId Revision revision ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRevisionPipelines: async (projectId: string, id: string, revisionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getPipelineRevisionPipelines', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPipelineRevisionPipelines', 'id', id)
            // verify required parameter 'revisionId' is not null or undefined
            assertParamExists('getPipelineRevisionPipelines', 'revisionId', revisionId)
            const localVarPath = `/projects/{project_id}/pipelines/{_id}/revisions/{revision_id}/pipelines`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"revision_id"}}`, encodeURIComponent(String(revisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get pipeline revisions
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {Array<'variables' | 'user' | 'outputs'>} [fields] Additional fields to return
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {boolean} [published] Filter pipelines by published status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRevisions: async (projectId: string, id: string, fields?: Array<'variables' | 'user' | 'outputs'>, limit?: number, offset?: number, published?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getPipelineRevisions', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPipelineRevisions', 'id', id)
            const localVarPath = `/projects/{project_id}/pipelines/{_id}/revisions`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (published !== undefined) {
                localVarQueryParameter['published'] = published;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List pipelines
         * @param {string} projectId Project ID
         * @param {'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc'} [sort] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [search] 
         * @param {boolean} [pinned] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelines: async (projectId: string, sort?: 'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc', limit?: number, offset?: number, search?: string, pinned?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listPipelines', 'projectId', projectId)
            const localVarPath = `/projects/{project_id}/pipelines`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (pinned !== undefined) {
                localVarQueryParameter['pinned'] = pinned;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Publish a pipeline revision
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishPipelineRevision: async (projectId: string, id: string, revisionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('publishPipelineRevision', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('publishPipelineRevision', 'id', id)
            // verify required parameter 'revisionId' is not null or undefined
            assertParamExists('publishPipelineRevision', 'revisionId', revisionId)
            const localVarPath = `/projects/{project_id}/pipelines/{_id}/revisions/{revision_id}/publish`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"revision_id"}}`, encodeURIComponent(String(revisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run pipeline
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {InlineObject11} inlineObject11 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runPipeline: async (projectId: string, id: string, revisionId: string, inlineObject11: InlineObject11, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('runPipeline', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('runPipeline', 'id', id)
            // verify required parameter 'revisionId' is not null or undefined
            assertParamExists('runPipeline', 'revisionId', revisionId)
            // verify required parameter 'inlineObject11' is not null or undefined
            assertParamExists('runPipeline', 'inlineObject11', inlineObject11)
            const localVarPath = `/projects/{project_id}/pipelines/{_id}/revisions/{revision_id}/run`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"revision_id"}}`, encodeURIComponent(String(revisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject11, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a pipeline
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {Pipeline} pipeline 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePipeline: async (projectId: string, id: string, pipeline: Pipeline, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updatePipeline', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePipeline', 'id', id)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('updatePipeline', 'pipeline', pipeline)
            const localVarPath = `/projects/{project_id}/pipelines/{_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipeline, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a pipeline revision
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {InlineObject7} inlineObject7 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePipelineRevision: async (projectId: string, id: string, revisionId: string, inlineObject7: InlineObject7, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updatePipelineRevision', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePipelineRevision', 'id', id)
            // verify required parameter 'revisionId' is not null or undefined
            assertParamExists('updatePipelineRevision', 'revisionId', revisionId)
            // verify required parameter 'inlineObject7' is not null or undefined
            assertParamExists('updatePipelineRevision', 'inlineObject7', inlineObject7)
            const localVarPath = `/projects/{project_id}/pipelines/{_id}/revisions/{revision_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"revision_id"}}`, encodeURIComponent(String(revisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject7, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PipelinesApi - functional programming interface
 * @export
 */
export const PipelinesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PipelinesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Clone pipeline
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {InlineObject10} inlineObject10 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clonePipeline(projectId: string, id: string, revisionId: string, inlineObject10: InlineObject10, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clonePipeline(projectId, id, revisionId, inlineObject10, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create pipeline
         * @param {string} projectId Project ID
         * @param {Pipeline} pipeline 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPipeline(projectId: string, pipeline: Pipeline, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse201>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPipeline(projectId, pipeline, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a pipeline revision
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {PipelineRevision} pipelineRevision 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPipelineRevision(projectId: string, id: string, pipelineRevision: PipelineRevision, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPipelineRevision(projectId, id, pipelineRevision, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete pipeline
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePipeline(projectId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePipeline(projectId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get pipeline
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipeline(projectId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipeline(projectId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get pipeline revision
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineRevision(projectId: string, id: string, revisionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineRevision>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineRevision(projectId, id, revisionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List pipeline revisions included in the steps of a given pipeline revision
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {string} revisionId Revision revision ID
         * @param {Array<'variables' | 'outputs' | 'steps' | 'layout'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineRevisionPipelineRevisions(projectId: string, id: string, revisionId: string, fields?: Array<'variables' | 'outputs' | 'steps' | 'layout'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineRevisionPipelineRevisions(projectId, id, revisionId, fields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List pipelines included in the steps of a given pipeline revision
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {string} revisionId Revision revision ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineRevisionPipelines(projectId: string, id: string, revisionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineRevisionPipelines(projectId, id, revisionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get pipeline revisions
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {Array<'variables' | 'user' | 'outputs'>} [fields] Additional fields to return
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {boolean} [published] Filter pipelines by published status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineRevisions(projectId: string, id: string, fields?: Array<'variables' | 'user' | 'outputs'>, limit?: number, offset?: number, published?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineRevisions(projectId, id, fields, limit, offset, published, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List pipelines
         * @param {string} projectId Project ID
         * @param {'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc'} [sort] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [search] 
         * @param {boolean} [pinned] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPipelines(projectId: string, sort?: 'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc', limit?: number, offset?: number, search?: string, pinned?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPipelines(projectId, sort, limit, offset, search, pinned, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Publish a pipeline revision
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishPipelineRevision(projectId: string, id: string, revisionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishPipelineRevision(projectId, id, revisionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Run pipeline
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {InlineObject11} inlineObject11 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runPipeline(projectId: string, id: string, revisionId: string, inlineObject11: InlineObject11, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse201>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runPipeline(projectId, id, revisionId, inlineObject11, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a pipeline
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {Pipeline} pipeline 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePipeline(projectId: string, id: string, pipeline: Pipeline, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePipeline(projectId, id, pipeline, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a pipeline revision
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {InlineObject7} inlineObject7 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePipelineRevision(projectId: string, id: string, revisionId: string, inlineObject7: InlineObject7, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePipelineRevision(projectId, id, revisionId, inlineObject7, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PipelinesApi - factory interface
 * @export
 */
export const PipelinesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PipelinesApiFp(configuration)
    return {
        /**
         * 
         * @summary Clone pipeline
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {InlineObject10} inlineObject10 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clonePipeline(projectId: string, id: string, revisionId: string, inlineObject10: InlineObject10, options?: any): AxiosPromise<InlineResponse2011> {
            return localVarFp.clonePipeline(projectId, id, revisionId, inlineObject10, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create pipeline
         * @param {string} projectId Project ID
         * @param {Pipeline} pipeline 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipeline(projectId: string, pipeline: Pipeline, options?: any): AxiosPromise<InlineResponse201> {
            return localVarFp.createPipeline(projectId, pipeline, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a pipeline revision
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {PipelineRevision} pipelineRevision 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipelineRevision(projectId: string, id: string, pipelineRevision: PipelineRevision, options?: any): AxiosPromise<InlineResponse2007> {
            return localVarFp.createPipelineRevision(projectId, id, pipelineRevision, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete pipeline
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipeline(projectId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePipeline(projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get pipeline
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipeline(projectId: string, id: string, options?: any): AxiosPromise<Pipeline> {
            return localVarFp.getPipeline(projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get pipeline revision
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRevision(projectId: string, id: string, revisionId: string, options?: any): AxiosPromise<PipelineRevision> {
            return localVarFp.getPipelineRevision(projectId, id, revisionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List pipeline revisions included in the steps of a given pipeline revision
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {string} revisionId Revision revision ID
         * @param {Array<'variables' | 'outputs' | 'steps' | 'layout'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRevisionPipelineRevisions(projectId: string, id: string, revisionId: string, fields?: Array<'variables' | 'outputs' | 'steps' | 'layout'>, options?: any): AxiosPromise<InlineResponse2008> {
            return localVarFp.getPipelineRevisionPipelineRevisions(projectId, id, revisionId, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List pipelines included in the steps of a given pipeline revision
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {string} revisionId Revision revision ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRevisionPipelines(projectId: string, id: string, revisionId: string, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.getPipelineRevisionPipelines(projectId, id, revisionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get pipeline revisions
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {Array<'variables' | 'user' | 'outputs'>} [fields] Additional fields to return
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {boolean} [published] Filter pipelines by published status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRevisions(projectId: string, id: string, fields?: Array<'variables' | 'user' | 'outputs'>, limit?: number, offset?: number, published?: boolean, options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.getPipelineRevisions(projectId, id, fields, limit, offset, published, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List pipelines
         * @param {string} projectId Project ID
         * @param {'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc'} [sort] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [search] 
         * @param {boolean} [pinned] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelines(projectId: string, sort?: 'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc', limit?: number, offset?: number, search?: string, pinned?: boolean, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.listPipelines(projectId, sort, limit, offset, search, pinned, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Publish a pipeline revision
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishPipelineRevision(projectId: string, id: string, revisionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.publishPipelineRevision(projectId, id, revisionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Run pipeline
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {InlineObject11} inlineObject11 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runPipeline(projectId: string, id: string, revisionId: string, inlineObject11: InlineObject11, options?: any): AxiosPromise<InlineResponse201> {
            return localVarFp.runPipeline(projectId, id, revisionId, inlineObject11, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a pipeline
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {Pipeline} pipeline 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePipeline(projectId: string, id: string, pipeline: Pipeline, options?: any): AxiosPromise<void> {
            return localVarFp.updatePipeline(projectId, id, pipeline, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a pipeline revision
         * @param {string} projectId Project ID
         * @param {string} id Pipeline ID
         * @param {string} revisionId Pipeline revision ID
         * @param {InlineObject7} inlineObject7 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePipelineRevision(projectId: string, id: string, revisionId: string, inlineObject7: InlineObject7, options?: any): AxiosPromise<void> {
            return localVarFp.updatePipelineRevision(projectId, id, revisionId, inlineObject7, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PipelinesApi - object-oriented interface
 * @export
 * @class PipelinesApi
 * @extends {BaseAPI}
 */
export class PipelinesApi extends BaseAPI {
    /**
     * 
     * @summary Clone pipeline
     * @param {string} projectId Project ID
     * @param {string} id Pipeline ID
     * @param {string} revisionId Pipeline revision ID
     * @param {InlineObject10} inlineObject10 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public clonePipeline(projectId: string, id: string, revisionId: string, inlineObject10: InlineObject10, options?: any) {
        return PipelinesApiFp(this.configuration).clonePipeline(projectId, id, revisionId, inlineObject10, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create pipeline
     * @param {string} projectId Project ID
     * @param {Pipeline} pipeline 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public createPipeline(projectId: string, pipeline: Pipeline, options?: any) {
        return PipelinesApiFp(this.configuration).createPipeline(projectId, pipeline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a pipeline revision
     * @param {string} projectId Project ID
     * @param {string} id Pipeline ID
     * @param {PipelineRevision} pipelineRevision 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public createPipelineRevision(projectId: string, id: string, pipelineRevision: PipelineRevision, options?: any) {
        return PipelinesApiFp(this.configuration).createPipelineRevision(projectId, id, pipelineRevision, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete pipeline
     * @param {string} projectId Project ID
     * @param {string} id Pipeline ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public deletePipeline(projectId: string, id: string, options?: any) {
        return PipelinesApiFp(this.configuration).deletePipeline(projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get pipeline
     * @param {string} projectId Project ID
     * @param {string} id Pipeline ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public getPipeline(projectId: string, id: string, options?: any) {
        return PipelinesApiFp(this.configuration).getPipeline(projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get pipeline revision
     * @param {string} projectId Project ID
     * @param {string} id Pipeline ID
     * @param {string} revisionId Pipeline revision ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public getPipelineRevision(projectId: string, id: string, revisionId: string, options?: any) {
        return PipelinesApiFp(this.configuration).getPipelineRevision(projectId, id, revisionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List pipeline revisions included in the steps of a given pipeline revision
     * @param {string} projectId Project ID
     * @param {string} id Pipeline ID
     * @param {string} revisionId Revision revision ID
     * @param {Array<'variables' | 'outputs' | 'steps' | 'layout'>} [fields] Additional fields to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public getPipelineRevisionPipelineRevisions(projectId: string, id: string, revisionId: string, fields?: Array<'variables' | 'outputs' | 'steps' | 'layout'>, options?: any) {
        return PipelinesApiFp(this.configuration).getPipelineRevisionPipelineRevisions(projectId, id, revisionId, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List pipelines included in the steps of a given pipeline revision
     * @param {string} projectId Project ID
     * @param {string} id Pipeline ID
     * @param {string} revisionId Revision revision ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public getPipelineRevisionPipelines(projectId: string, id: string, revisionId: string, options?: any) {
        return PipelinesApiFp(this.configuration).getPipelineRevisionPipelines(projectId, id, revisionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get pipeline revisions
     * @param {string} projectId Project ID
     * @param {string} id Pipeline ID
     * @param {Array<'variables' | 'user' | 'outputs'>} [fields] Additional fields to return
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {boolean} [published] Filter pipelines by published status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public getPipelineRevisions(projectId: string, id: string, fields?: Array<'variables' | 'user' | 'outputs'>, limit?: number, offset?: number, published?: boolean, options?: any) {
        return PipelinesApiFp(this.configuration).getPipelineRevisions(projectId, id, fields, limit, offset, published, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List pipelines
     * @param {string} projectId Project ID
     * @param {'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc'} [sort] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [search] 
     * @param {boolean} [pinned] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public listPipelines(projectId: string, sort?: 'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc', limit?: number, offset?: number, search?: string, pinned?: boolean, options?: any) {
        return PipelinesApiFp(this.configuration).listPipelines(projectId, sort, limit, offset, search, pinned, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Publish a pipeline revision
     * @param {string} projectId Project ID
     * @param {string} id Pipeline ID
     * @param {string} revisionId Pipeline revision ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public publishPipelineRevision(projectId: string, id: string, revisionId: string, options?: any) {
        return PipelinesApiFp(this.configuration).publishPipelineRevision(projectId, id, revisionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Run pipeline
     * @param {string} projectId Project ID
     * @param {string} id Pipeline ID
     * @param {string} revisionId Pipeline revision ID
     * @param {InlineObject11} inlineObject11 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public runPipeline(projectId: string, id: string, revisionId: string, inlineObject11: InlineObject11, options?: any) {
        return PipelinesApiFp(this.configuration).runPipeline(projectId, id, revisionId, inlineObject11, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a pipeline
     * @param {string} projectId Project ID
     * @param {string} id Pipeline ID
     * @param {Pipeline} pipeline 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public updatePipeline(projectId: string, id: string, pipeline: Pipeline, options?: any) {
        return PipelinesApiFp(this.configuration).updatePipeline(projectId, id, pipeline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a pipeline revision
     * @param {string} projectId Project ID
     * @param {string} id Pipeline ID
     * @param {string} revisionId Pipeline revision ID
     * @param {InlineObject7} inlineObject7 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public updatePipelineRevision(projectId: string, id: string, revisionId: string, inlineObject7: InlineObject7, options?: any) {
        return PipelinesApiFp(this.configuration).updatePipelineRevision(projectId, id, revisionId, inlineObject7, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add project notification channel
         * @param {string} projectId Project ID
         * @param {NotificationChannel} notificationChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProjectNotificationChannel: async (projectId: string, notificationChannel: NotificationChannel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('addProjectNotificationChannel', 'projectId', projectId)
            // verify required parameter 'notificationChannel' is not null or undefined
            assertParamExists('addProjectNotificationChannel', 'notificationChannel', notificationChannel)
            const localVarPath = `/projects/{project_id}/notification_channels`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationChannel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create organization project
         * @param {string} organizationId Organization ID
         * @param {Project} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationProject: async (organizationId: string, project: Project, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createOrganizationProject', 'organizationId', organizationId)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('createOrganizationProject', 'project', project)
            const localVarPath = `/organizations/{organization_id}/projects`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(project, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProject', 'projectId', projectId)
            const localVarPath = `/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project
         * @param {string} projectId Project ID
         * @param {Array<'variables' | 'notification_channels' | 'organization'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (projectId: string, fields?: Array<'variables' | 'notification_channels' | 'organization'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProject', 'projectId', projectId)
            const localVarPath = `/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization projects
         * @param {string} organizationId Organization ID
         * @param {'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc'} [sort] 
         * @param {string} [search] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationProjects: async (organizationId: string, sort?: 'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc', search?: string, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationProjects', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/projects`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List projects
         * @param {'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc'} [sort] 
         * @param {string} [search] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<'organization'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects: async (sort?: 'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc', search?: string, limit?: number, offset?: number, fields?: Array<'organization'>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Publish project catalog
         * @param {string} projectId Project ID
         * @param {InlineObject15} inlineObject15 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishProjectCatalog: async (projectId: string, inlineObject15: InlineObject15, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('publishProjectCatalog', 'projectId', projectId)
            // verify required parameter 'inlineObject15' is not null or undefined
            assertParamExists('publishProjectCatalog', 'inlineObject15', inlineObject15)
            const localVarPath = `/projects/{project_id}/publish`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject15, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove project notification channel
         * @param {string} projectId Project ID
         * @param {string} notificationChannelId Notification Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeProjectNotificationChannel: async (projectId: string, notificationChannelId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('removeProjectNotificationChannel', 'projectId', projectId)
            // verify required parameter 'notificationChannelId' is not null or undefined
            assertParamExists('removeProjectNotificationChannel', 'notificationChannelId', notificationChannelId)
            const localVarPath = `/projects/{project_id}/notification_channels/{notification_channel_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"notification_channel_id"}}`, encodeURIComponent(String(notificationChannelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project
         * @param {string} projectId Project ID
         * @param {Project} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject: async (projectId: string, project: Project, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateProject', 'projectId', projectId)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('updateProject', 'project', project)
            const localVarPath = `/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(project, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project notification channel
         * @param {string} projectId Project ID
         * @param {string} notificationChannelId Notification Channel ID
         * @param {NotificationChannel} notificationChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectNotificationChannel: async (projectId: string, notificationChannelId: string, notificationChannel: NotificationChannel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateProjectNotificationChannel', 'projectId', projectId)
            // verify required parameter 'notificationChannelId' is not null or undefined
            assertParamExists('updateProjectNotificationChannel', 'notificationChannelId', notificationChannelId)
            // verify required parameter 'notificationChannel' is not null or undefined
            assertParamExists('updateProjectNotificationChannel', 'notificationChannel', notificationChannel)
            const localVarPath = `/projects/{project_id}/notification_channels/{notification_channel_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"notification_channel_id"}}`, encodeURIComponent(String(notificationChannelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationChannel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add project notification channel
         * @param {string} projectId Project ID
         * @param {NotificationChannel} notificationChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addProjectNotificationChannel(projectId: string, notificationChannel: NotificationChannel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProjectNotificationChannel(projectId, notificationChannel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create organization project
         * @param {string} organizationId Organization ID
         * @param {Project} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationProject(organizationId: string, project: Project, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse201>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationProject(organizationId, project, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProject(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProject(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get project
         * @param {string} projectId Project ID
         * @param {Array<'variables' | 'notification_channels' | 'organization'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(projectId: string, fields?: Array<'variables' | 'notification_channels' | 'organization'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(projectId, fields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List organization projects
         * @param {string} organizationId Organization ID
         * @param {'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc'} [sort] 
         * @param {string} [search] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationProjects(organizationId: string, sort?: 'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc', search?: string, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationProjects(organizationId, sort, search, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List projects
         * @param {'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc'} [sort] 
         * @param {string} [search] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<'organization'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjects(sort?: 'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc', search?: string, limit?: number, offset?: number, fields?: Array<'organization'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjects(sort, search, limit, offset, fields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Publish project catalog
         * @param {string} projectId Project ID
         * @param {InlineObject15} inlineObject15 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishProjectCatalog(projectId: string, inlineObject15: InlineObject15, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishProjectCatalog(projectId, inlineObject15, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove project notification channel
         * @param {string} projectId Project ID
         * @param {string} notificationChannelId Notification Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeProjectNotificationChannel(projectId: string, notificationChannelId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeProjectNotificationChannel(projectId, notificationChannelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update project
         * @param {string} projectId Project ID
         * @param {Project} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProject(projectId: string, project: Project, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(projectId, project, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update project notification channel
         * @param {string} projectId Project ID
         * @param {string} notificationChannelId Notification Channel ID
         * @param {NotificationChannel} notificationChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProjectNotificationChannel(projectId: string, notificationChannelId: string, notificationChannel: NotificationChannel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProjectNotificationChannel(projectId, notificationChannelId, notificationChannel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add project notification channel
         * @param {string} projectId Project ID
         * @param {NotificationChannel} notificationChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProjectNotificationChannel(projectId: string, notificationChannel: NotificationChannel, options?: any): AxiosPromise<void> {
            return localVarFp.addProjectNotificationChannel(projectId, notificationChannel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create organization project
         * @param {string} organizationId Organization ID
         * @param {Project} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationProject(organizationId: string, project: Project, options?: any): AxiosPromise<InlineResponse201> {
            return localVarFp.createOrganizationProject(organizationId, project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(projectId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get project
         * @param {string} projectId Project ID
         * @param {Array<'variables' | 'notification_channels' | 'organization'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(projectId: string, fields?: Array<'variables' | 'notification_channels' | 'organization'>, options?: any): AxiosPromise<Project> {
            return localVarFp.getProject(projectId, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization projects
         * @param {string} organizationId Organization ID
         * @param {'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc'} [sort] 
         * @param {string} [search] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationProjects(organizationId: string, sort?: 'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc', search?: string, offset?: number, limit?: number, options?: any): AxiosPromise<InlineResponse2009> {
            return localVarFp.listOrganizationProjects(organizationId, sort, search, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List projects
         * @param {'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc'} [sort] 
         * @param {string} [search] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<'organization'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(sort?: 'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc', search?: string, limit?: number, offset?: number, fields?: Array<'organization'>, options?: any): AxiosPromise<InlineResponse2009> {
            return localVarFp.listProjects(sort, search, limit, offset, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Publish project catalog
         * @param {string} projectId Project ID
         * @param {InlineObject15} inlineObject15 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishProjectCatalog(projectId: string, inlineObject15: InlineObject15, options?: any): AxiosPromise<void> {
            return localVarFp.publishProjectCatalog(projectId, inlineObject15, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove project notification channel
         * @param {string} projectId Project ID
         * @param {string} notificationChannelId Notification Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeProjectNotificationChannel(projectId: string, notificationChannelId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeProjectNotificationChannel(projectId, notificationChannelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update project
         * @param {string} projectId Project ID
         * @param {Project} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(projectId: string, project: Project, options?: any): AxiosPromise<void> {
            return localVarFp.updateProject(projectId, project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update project notification channel
         * @param {string} projectId Project ID
         * @param {string} notificationChannelId Notification Channel ID
         * @param {NotificationChannel} notificationChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectNotificationChannel(projectId: string, notificationChannelId: string, notificationChannel: NotificationChannel, options?: any): AxiosPromise<void> {
            return localVarFp.updateProjectNotificationChannel(projectId, notificationChannelId, notificationChannel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Add project notification channel
     * @param {string} projectId Project ID
     * @param {NotificationChannel} notificationChannel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public addProjectNotificationChannel(projectId: string, notificationChannel: NotificationChannel, options?: any) {
        return ProjectsApiFp(this.configuration).addProjectNotificationChannel(projectId, notificationChannel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create organization project
     * @param {string} organizationId Organization ID
     * @param {Project} project 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createOrganizationProject(organizationId: string, project: Project, options?: any) {
        return ProjectsApiFp(this.configuration).createOrganizationProject(organizationId, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete project
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProject(projectId: string, options?: any) {
        return ProjectsApiFp(this.configuration).deleteProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get project
     * @param {string} projectId Project ID
     * @param {Array<'variables' | 'notification_channels' | 'organization'>} [fields] Additional fields to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProject(projectId: string, fields?: Array<'variables' | 'notification_channels' | 'organization'>, options?: any) {
        return ProjectsApiFp(this.configuration).getProject(projectId, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization projects
     * @param {string} organizationId Organization ID
     * @param {'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc'} [sort] 
     * @param {string} [search] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listOrganizationProjects(organizationId: string, sort?: 'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc', search?: string, offset?: number, limit?: number, options?: any) {
        return ProjectsApiFp(this.configuration).listOrganizationProjects(organizationId, sort, search, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List projects
     * @param {'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc'} [sort] 
     * @param {string} [search] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {Array<'organization'>} [fields] Additional fields to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProjects(sort?: 'modified_asc' | 'modified_desc' | 'name_asc' | 'name_desc', search?: string, limit?: number, offset?: number, fields?: Array<'organization'>, options?: any) {
        return ProjectsApiFp(this.configuration).listProjects(sort, search, limit, offset, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Publish project catalog
     * @param {string} projectId Project ID
     * @param {InlineObject15} inlineObject15 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public publishProjectCatalog(projectId: string, inlineObject15: InlineObject15, options?: any) {
        return ProjectsApiFp(this.configuration).publishProjectCatalog(projectId, inlineObject15, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove project notification channel
     * @param {string} projectId Project ID
     * @param {string} notificationChannelId Notification Channel ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public removeProjectNotificationChannel(projectId: string, notificationChannelId: string, options?: any) {
        return ProjectsApiFp(this.configuration).removeProjectNotificationChannel(projectId, notificationChannelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update project
     * @param {string} projectId Project ID
     * @param {Project} project 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public updateProject(projectId: string, project: Project, options?: any) {
        return ProjectsApiFp(this.configuration).updateProject(projectId, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update project notification channel
     * @param {string} projectId Project ID
     * @param {string} notificationChannelId Notification Channel ID
     * @param {NotificationChannel} notificationChannel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public updateProjectNotificationChannel(projectId: string, notificationChannelId: string, notificationChannel: NotificationChannel, options?: any) {
        return ProjectsApiFp(this.configuration).updateProjectNotificationChannel(projectId, notificationChannelId, notificationChannel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RunsApi - axios parameter creator
 * @export
 */
export const RunsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete run
         * @param {string} projectId Project ID
         * @param {string} id Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun: async (projectId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteRun', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRun', 'id', id)
            const localVarPath = `/projects/{project_id}/runs/{_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} projectId Project ID
         * @param {string} id Run ID
         * @param {Array<'job' | 'pipeline' | 'runner_agent' | 'pipeline_revision'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun: async (projectId: string, id: string, fields?: Array<'job' | 'pipeline' | 'runner_agent' | 'pipeline_revision'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getRun', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRun', 'id', id)
            const localVarPath = `/projects/{project_id}/runs/{_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List runs for a project
         * @param {string} projectId Project ID
         * @param {string} [pipelineId] Pipeline ID
         * @param {string} [jobId] Job ID
         * @param {'created_desc' | 'created_asc'} [sort] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<'job' | 'pipeline' | 'runner_agent'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectRuns: async (projectId: string, pipelineId?: string, jobId?: string, sort?: 'created_desc' | 'created_asc', limit?: number, offset?: number, fields?: Array<'job' | 'pipeline' | 'runner_agent'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectRuns', 'projectId', projectId)
            const localVarPath = `/projects/{project_id}/runs`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pipelineId !== undefined) {
                localVarQueryParameter['pipeline_id'] = pipelineId;
            }

            if (jobId !== undefined) {
                localVarQueryParameter['job_id'] = jobId;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rerun a run
         * @param {string} projectId Project ID
         * @param {string} id Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rerunRun: async (projectId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('rerunRun', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rerunRun', 'id', id)
            const localVarPath = `/projects/{project_id}/runs/{_id}/run`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a run
         * @param {string} projectId Project ID
         * @param {string} id Run ID
         * @param {InlineObject14} inlineObject14 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRun: async (projectId: string, id: string, inlineObject14: InlineObject14, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateRun', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRun', 'id', id)
            // verify required parameter 'inlineObject14' is not null or undefined
            assertParamExists('updateRun', 'inlineObject14', inlineObject14)
            const localVarPath = `/projects/{project_id}/runs/{_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject14, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunsApi - functional programming interface
 * @export
 */
export const RunsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RunsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete run
         * @param {string} projectId Project ID
         * @param {string} id Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRun(projectId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRun(projectId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get run
         * @param {string} projectId Project ID
         * @param {string} id Run ID
         * @param {Array<'job' | 'pipeline' | 'runner_agent' | 'pipeline_revision'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRun(projectId: string, id: string, fields?: Array<'job' | 'pipeline' | 'runner_agent' | 'pipeline_revision'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Run>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRun(projectId, id, fields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List runs for a project
         * @param {string} projectId Project ID
         * @param {string} [pipelineId] Pipeline ID
         * @param {string} [jobId] Job ID
         * @param {'created_desc' | 'created_asc'} [sort] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<'job' | 'pipeline' | 'runner_agent'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectRuns(projectId: string, pipelineId?: string, jobId?: string, sort?: 'created_desc' | 'created_asc', limit?: number, offset?: number, fields?: Array<'job' | 'pipeline' | 'runner_agent'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectRuns(projectId, pipelineId, jobId, sort, limit, offset, fields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Rerun a run
         * @param {string} projectId Project ID
         * @param {string} id Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rerunRun(projectId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse201>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rerunRun(projectId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a run
         * @param {string} projectId Project ID
         * @param {string} id Run ID
         * @param {InlineObject14} inlineObject14 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRun(projectId: string, id: string, inlineObject14: InlineObject14, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRun(projectId, id, inlineObject14, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RunsApi - factory interface
 * @export
 */
export const RunsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RunsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete run
         * @param {string} projectId Project ID
         * @param {string} id Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun(projectId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRun(projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get run
         * @param {string} projectId Project ID
         * @param {string} id Run ID
         * @param {Array<'job' | 'pipeline' | 'runner_agent' | 'pipeline_revision'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun(projectId: string, id: string, fields?: Array<'job' | 'pipeline' | 'runner_agent' | 'pipeline_revision'>, options?: any): AxiosPromise<Run> {
            return localVarFp.getRun(projectId, id, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List runs for a project
         * @param {string} projectId Project ID
         * @param {string} [pipelineId] Pipeline ID
         * @param {string} [jobId] Job ID
         * @param {'created_desc' | 'created_asc'} [sort] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<'job' | 'pipeline' | 'runner_agent'>} [fields] Additional fields to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectRuns(projectId: string, pipelineId?: string, jobId?: string, sort?: 'created_desc' | 'created_asc', limit?: number, offset?: number, fields?: Array<'job' | 'pipeline' | 'runner_agent'>, options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.listProjectRuns(projectId, pipelineId, jobId, sort, limit, offset, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rerun a run
         * @param {string} projectId Project ID
         * @param {string} id Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rerunRun(projectId: string, id: string, options?: any): AxiosPromise<InlineResponse201> {
            return localVarFp.rerunRun(projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a run
         * @param {string} projectId Project ID
         * @param {string} id Run ID
         * @param {InlineObject14} inlineObject14 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRun(projectId: string, id: string, inlineObject14: InlineObject14, options?: any): AxiosPromise<void> {
            return localVarFp.updateRun(projectId, id, inlineObject14, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RunsApi - object-oriented interface
 * @export
 * @class RunsApi
 * @extends {BaseAPI}
 */
export class RunsApi extends BaseAPI {
    /**
     * 
     * @summary Delete run
     * @param {string} projectId Project ID
     * @param {string} id Run ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public deleteRun(projectId: string, id: string, options?: any) {
        return RunsApiFp(this.configuration).deleteRun(projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get run
     * @param {string} projectId Project ID
     * @param {string} id Run ID
     * @param {Array<'job' | 'pipeline' | 'runner_agent' | 'pipeline_revision'>} [fields] Additional fields to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public getRun(projectId: string, id: string, fields?: Array<'job' | 'pipeline' | 'runner_agent' | 'pipeline_revision'>, options?: any) {
        return RunsApiFp(this.configuration).getRun(projectId, id, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List runs for a project
     * @param {string} projectId Project ID
     * @param {string} [pipelineId] Pipeline ID
     * @param {string} [jobId] Job ID
     * @param {'created_desc' | 'created_asc'} [sort] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {Array<'job' | 'pipeline' | 'runner_agent'>} [fields] Additional fields to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public listProjectRuns(projectId: string, pipelineId?: string, jobId?: string, sort?: 'created_desc' | 'created_asc', limit?: number, offset?: number, fields?: Array<'job' | 'pipeline' | 'runner_agent'>, options?: any) {
        return RunsApiFp(this.configuration).listProjectRuns(projectId, pipelineId, jobId, sort, limit, offset, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rerun a run
     * @param {string} projectId Project ID
     * @param {string} id Run ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public rerunRun(projectId: string, id: string, options?: any) {
        return RunsApiFp(this.configuration).rerunRun(projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a run
     * @param {string} projectId Project ID
     * @param {string} id Run ID
     * @param {InlineObject14} inlineObject14 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public updateRun(projectId: string, id: string, inlineObject14: InlineObject14, options?: any) {
        return RunsApiFp(this.configuration).updateRun(projectId, id, inlineObject14, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TokensApi - axios parameter creator
 * @export
 */
export const TokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create authorization token
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createToken: async (inlineObject?: InlineObject, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete token
         * @param {string} id Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteToken', 'id', id)
            const localVarPath = `/tokens/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List authorization tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTokens: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokensApi - functional programming interface
 * @export
 */
export const TokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokensApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create authorization token
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createToken(inlineObject?: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createToken(inlineObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete token
         * @param {string} id Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteToken(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteToken(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List authorization tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTokens(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTokens(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TokensApi - factory interface
 * @export
 */
export const TokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokensApiFp(configuration)
    return {
        /**
         * 
         * @summary Create authorization token
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createToken(inlineObject?: InlineObject, options?: any): AxiosPromise<Token> {
            return localVarFp.createToken(inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete token
         * @param {string} id Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken(id: string, options?: any): AxiosPromise<Token> {
            return localVarFp.deleteToken(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List authorization tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTokens(options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.listTokens(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
export class TokensApi extends BaseAPI {
    /**
     * 
     * @summary Create authorization token
     * @param {InlineObject} [inlineObject] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public createToken(inlineObject?: InlineObject, options?: any) {
        return TokensApiFp(this.configuration).createToken(inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete token
     * @param {string} id Token ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public deleteToken(id: string, options?: any) {
        return TokensApiFp(this.configuration).deleteToken(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List authorization tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public listTokens(options?: any) {
        return TokensApiFp(this.configuration).listTokens(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add organization user
         * @param {string} organizationId Organization ID
         * @param {InlineObject18} inlineObject18 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationUser: async (organizationId: string, inlineObject18: InlineObject18, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrganizationUser', 'organizationId', organizationId)
            // verify required parameter 'inlineObject18' is not null or undefined
            assertParamExists('addOrganizationUser', 'inlineObject18', inlineObject18)
            const localVarPath = `/organizations/{organization_id}/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject18, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add project group
         * @param {string} projectId Project ID
         * @param {InlineObject5} inlineObject5 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProjectGroup: async (projectId: string, inlineObject5: InlineObject5, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('addProjectGroup', 'projectId', projectId)
            // verify required parameter 'inlineObject5' is not null or undefined
            assertParamExists('addProjectGroup', 'inlineObject5', inlineObject5)
            const localVarPath = `/projects/{project_id}/groups`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject5, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add project user
         * @param {string} projectId Project ID
         * @param {InlineObject3} inlineObject3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProjectUser: async (projectId: string, inlineObject3: InlineObject3, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('addProjectUser', 'projectId', projectId)
            // verify required parameter 'inlineObject3' is not null or undefined
            assertParamExists('addProjectUser', 'inlineObject3', inlineObject3)
            const localVarPath = `/projects/{project_id}/users`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject3, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create organization group
         * @param {string} organizationId Organization ID
         * @param {UserGroup} userGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationGroup: async (organizationId: string, userGroup: UserGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createOrganizationGroup', 'organizationId', organizationId)
            // verify required parameter 'userGroup' is not null or undefined
            assertParamExists('createOrganizationGroup', 'userGroup', userGroup)
            const localVarPath = `/organizations/{organization_id}/groups`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete organization group
         * @param {string} organizationId Organization ID
         * @param {string} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationGroup: async (organizationId: string, groupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganizationGroup', 'organizationId', organizationId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteOrganizationGroup', 'groupId', groupId)
            const localVarPath = `/organizations/{organization_id}/groups/{group_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization groups
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationGroups: async (organizationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationGroups', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/groups`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization invites
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationInvites: async (organizationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationInvites', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/invites`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization users
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationUsers: async (organizationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationUsers', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project groups
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectGroups: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectGroups', 'projectId', projectId)
            const localVarPath = `/projects/{project_id}/groups`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project invites
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectInvites: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectInvites', 'projectId', projectId)
            const localVarPath = `/projects/{project_id}/invites`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project users
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectUsers: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectUsers', 'projectId', projectId)
            const localVarPath = `/projects/{project_id}/users`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List user activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserActivity: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/activity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove organization user
         * @param {string} organizationId Organization ID
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrganizationUser: async (organizationId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeOrganizationUser', 'organizationId', organizationId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeOrganizationUser', 'id', id)
            const localVarPath = `/organizations/{organization_id}/users/{_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove project group
         * @param {string} projectId Project ID
         * @param {string} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeProjectGroup: async (projectId: string, groupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('removeProjectGroup', 'projectId', projectId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('removeProjectGroup', 'groupId', groupId)
            const localVarPath = `/projects/{project_id}/groups/{group_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove project user
         * @param {string} projectId Project ID
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeProjectUser: async (projectId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('removeProjectUser', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeProjectUser', 'id', id)
            const localVarPath = `/projects/{project_id}/users/{_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resend organization invite
         * @param {string} organizationId Organization ID
         * @param {string} id Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendOrganizationInvite: async (organizationId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('resendOrganizationInvite', 'organizationId', organizationId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resendOrganizationInvite', 'id', id)
            const localVarPath = `/organizations/{organization_id}/invites/{_id}/resend`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resend project invite
         * @param {string} projectId Project ID
         * @param {string} id Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendProjectInvite: async (projectId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('resendProjectInvite', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resendProjectInvite', 'id', id)
            const localVarPath = `/projects/{project_id}/invites/{_id}/resend`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke organization invite
         * @param {string} organizationId Organization ID
         * @param {string} id Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeOrganizationInvite: async (organizationId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('revokeOrganizationInvite', 'organizationId', organizationId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('revokeOrganizationInvite', 'id', id)
            const localVarPath = `/organizations/{organization_id}/invites/{_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke project invite
         * @param {string} projectId Project ID
         * @param {string} id Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeProjectInvite: async (projectId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('revokeProjectInvite', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('revokeProjectInvite', 'id', id)
            const localVarPath = `/projects/{project_id}/invites/{_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update organization group
         * @param {string} organizationId Organization ID
         * @param {string} groupId Group ID
         * @param {UserGroup} userGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationGroup: async (organizationId: string, groupId: string, userGroup: UserGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganizationGroup', 'organizationId', organizationId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateOrganizationGroup', 'groupId', groupId)
            // verify required parameter 'userGroup' is not null or undefined
            assertParamExists('updateOrganizationGroup', 'userGroup', userGroup)
            const localVarPath = `/organizations/{organization_id}/groups/{group_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update organization user
         * @param {string} organizationId Organization ID
         * @param {string} id User ID
         * @param {InlineObject19} inlineObject19 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationUser: async (organizationId: string, id: string, inlineObject19: InlineObject19, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganizationUser', 'organizationId', organizationId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateOrganizationUser', 'id', id)
            // verify required parameter 'inlineObject19' is not null or undefined
            assertParamExists('updateOrganizationUser', 'inlineObject19', inlineObject19)
            const localVarPath = `/organizations/{organization_id}/users/{_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject19, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project group
         * @param {string} projectId Project ID
         * @param {string} groupId Group ID
         * @param {InlineObject6} inlineObject6 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectGroup: async (projectId: string, groupId: string, inlineObject6: InlineObject6, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateProjectGroup', 'projectId', projectId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateProjectGroup', 'groupId', groupId)
            // verify required parameter 'inlineObject6' is not null or undefined
            assertParamExists('updateProjectGroup', 'inlineObject6', inlineObject6)
            const localVarPath = `/projects/{project_id}/groups/{group_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject6, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project user
         * @param {string} projectId Project ID
         * @param {string} id User ID
         * @param {InlineObject4} inlineObject4 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectUser: async (projectId: string, id: string, inlineObject4: InlineObject4, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateProjectUser', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProjectUser', 'id', id)
            // verify required parameter 'inlineObject4' is not null or undefined
            assertParamExists('updateProjectUser', 'inlineObject4', inlineObject4)
            const localVarPath = `/projects/{project_id}/users/{_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject4, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user password
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword: async (inlineObject2: InlineObject2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject2' is not null or undefined
            assertParamExists('updateUserPassword', 'inlineObject2', inlineObject2)
            const localVarPath = `/user/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user profile
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserProfile: async (inlineObject1: InlineObject1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject1' is not null or undefined
            assertParamExists('updateUserProfile', 'inlineObject1', inlineObject1)
            const localVarPath = `/user/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add organization user
         * @param {string} organizationId Organization ID
         * @param {InlineObject18} inlineObject18 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrganizationUser(organizationId: string, inlineObject18: InlineObject18, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrganizationUser(organizationId, inlineObject18, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add project group
         * @param {string} projectId Project ID
         * @param {InlineObject5} inlineObject5 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addProjectGroup(projectId: string, inlineObject5: InlineObject5, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProjectGroup(projectId, inlineObject5, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add project user
         * @param {string} projectId Project ID
         * @param {InlineObject3} inlineObject3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addProjectUser(projectId: string, inlineObject3: InlineObject3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProjectUser(projectId, inlineObject3, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create organization group
         * @param {string} organizationId Organization ID
         * @param {UserGroup} userGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationGroup(organizationId: string, userGroup: UserGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationGroup(organizationId, userGroup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete organization group
         * @param {string} organizationId Organization ID
         * @param {string} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationGroup(organizationId: string, groupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationGroup(organizationId, groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List organization groups
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationGroups(organizationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20019>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationGroups(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List organization invites
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationInvites(organizationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20018>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationInvites(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List organization users
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationUsers(organizationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationUsers(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List project groups
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectGroups(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectGroups(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List project invites
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectInvites(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectInvites(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List project users
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectUsers(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectUsers(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List user activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserActivity(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserActivity(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove organization user
         * @param {string} organizationId Organization ID
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOrganizationUser(organizationId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeOrganizationUser(organizationId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove project group
         * @param {string} projectId Project ID
         * @param {string} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeProjectGroup(projectId: string, groupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeProjectGroup(projectId, groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove project user
         * @param {string} projectId Project ID
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeProjectUser(projectId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeProjectUser(projectId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Resend organization invite
         * @param {string} organizationId Organization ID
         * @param {string} id Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendOrganizationInvite(organizationId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendOrganizationInvite(organizationId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Resend project invite
         * @param {string} projectId Project ID
         * @param {string} id Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendProjectInvite(projectId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendProjectInvite(projectId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Revoke organization invite
         * @param {string} organizationId Organization ID
         * @param {string} id Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeOrganizationInvite(organizationId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeOrganizationInvite(organizationId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Revoke project invite
         * @param {string} projectId Project ID
         * @param {string} id Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeProjectInvite(projectId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeProjectInvite(projectId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update organization group
         * @param {string} organizationId Organization ID
         * @param {string} groupId Group ID
         * @param {UserGroup} userGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationGroup(organizationId: string, groupId: string, userGroup: UserGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationGroup(organizationId, groupId, userGroup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update organization user
         * @param {string} organizationId Organization ID
         * @param {string} id User ID
         * @param {InlineObject19} inlineObject19 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationUser(organizationId: string, id: string, inlineObject19: InlineObject19, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationUser(organizationId, id, inlineObject19, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update project group
         * @param {string} projectId Project ID
         * @param {string} groupId Group ID
         * @param {InlineObject6} inlineObject6 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProjectGroup(projectId: string, groupId: string, inlineObject6: InlineObject6, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProjectGroup(projectId, groupId, inlineObject6, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update project user
         * @param {string} projectId Project ID
         * @param {string} id User ID
         * @param {InlineObject4} inlineObject4 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProjectUser(projectId: string, id: string, inlineObject4: InlineObject4, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProjectUser(projectId, id, inlineObject4, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user password
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPassword(inlineObject2: InlineObject2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPassword(inlineObject2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user profile
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserProfile(inlineObject1: InlineObject1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserProfile(inlineObject1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Add organization user
         * @param {string} organizationId Organization ID
         * @param {InlineObject18} inlineObject18 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationUser(organizationId: string, inlineObject18: InlineObject18, options?: any): AxiosPromise<void> {
            return localVarFp.addOrganizationUser(organizationId, inlineObject18, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add project group
         * @param {string} projectId Project ID
         * @param {InlineObject5} inlineObject5 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProjectGroup(projectId: string, inlineObject5: InlineObject5, options?: any): AxiosPromise<void> {
            return localVarFp.addProjectGroup(projectId, inlineObject5, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add project user
         * @param {string} projectId Project ID
         * @param {InlineObject3} inlineObject3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProjectUser(projectId: string, inlineObject3: InlineObject3, options?: any): AxiosPromise<void> {
            return localVarFp.addProjectUser(projectId, inlineObject3, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create organization group
         * @param {string} organizationId Organization ID
         * @param {UserGroup} userGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationGroup(organizationId: string, userGroup: UserGroup, options?: any): AxiosPromise<void> {
            return localVarFp.createOrganizationGroup(organizationId, userGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete organization group
         * @param {string} organizationId Organization ID
         * @param {string} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationGroup(organizationId: string, groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationGroup(organizationId, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any): AxiosPromise<User> {
            return localVarFp.getUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization groups
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationGroups(organizationId: string, options?: any): AxiosPromise<InlineResponse20019> {
            return localVarFp.listOrganizationGroups(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization invites
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationInvites(organizationId: string, options?: any): AxiosPromise<InlineResponse20018> {
            return localVarFp.listOrganizationInvites(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization users
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationUsers(organizationId: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.listOrganizationUsers(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List project groups
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectGroups(projectId: string, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.listProjectGroups(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List project invites
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectInvites(projectId: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.listProjectInvites(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List project users
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectUsers(projectId: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.listProjectUsers(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List user activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserActivity(options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.listUserActivity(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove organization user
         * @param {string} organizationId Organization ID
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrganizationUser(organizationId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeOrganizationUser(organizationId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove project group
         * @param {string} projectId Project ID
         * @param {string} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeProjectGroup(projectId: string, groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeProjectGroup(projectId, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove project user
         * @param {string} projectId Project ID
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeProjectUser(projectId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeProjectUser(projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resend organization invite
         * @param {string} organizationId Organization ID
         * @param {string} id Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendOrganizationInvite(organizationId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.resendOrganizationInvite(organizationId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resend project invite
         * @param {string} projectId Project ID
         * @param {string} id Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendProjectInvite(projectId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.resendProjectInvite(projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke organization invite
         * @param {string} organizationId Organization ID
         * @param {string} id Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeOrganizationInvite(organizationId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.revokeOrganizationInvite(organizationId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke project invite
         * @param {string} projectId Project ID
         * @param {string} id Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeProjectInvite(projectId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.revokeProjectInvite(projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update organization group
         * @param {string} organizationId Organization ID
         * @param {string} groupId Group ID
         * @param {UserGroup} userGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationGroup(organizationId: string, groupId: string, userGroup: UserGroup, options?: any): AxiosPromise<void> {
            return localVarFp.updateOrganizationGroup(organizationId, groupId, userGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update organization user
         * @param {string} organizationId Organization ID
         * @param {string} id User ID
         * @param {InlineObject19} inlineObject19 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationUser(organizationId: string, id: string, inlineObject19: InlineObject19, options?: any): AxiosPromise<void> {
            return localVarFp.updateOrganizationUser(organizationId, id, inlineObject19, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update project group
         * @param {string} projectId Project ID
         * @param {string} groupId Group ID
         * @param {InlineObject6} inlineObject6 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectGroup(projectId: string, groupId: string, inlineObject6: InlineObject6, options?: any): AxiosPromise<void> {
            return localVarFp.updateProjectGroup(projectId, groupId, inlineObject6, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update project user
         * @param {string} projectId Project ID
         * @param {string} id User ID
         * @param {InlineObject4} inlineObject4 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectUser(projectId: string, id: string, inlineObject4: InlineObject4, options?: any): AxiosPromise<void> {
            return localVarFp.updateProjectUser(projectId, id, inlineObject4, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user password
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword(inlineObject2: InlineObject2, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserPassword(inlineObject2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user profile
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserProfile(inlineObject1: InlineObject1, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserProfile(inlineObject1, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Add organization user
     * @param {string} organizationId Organization ID
     * @param {InlineObject18} inlineObject18 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public addOrganizationUser(organizationId: string, inlineObject18: InlineObject18, options?: any) {
        return UsersApiFp(this.configuration).addOrganizationUser(organizationId, inlineObject18, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add project group
     * @param {string} projectId Project ID
     * @param {InlineObject5} inlineObject5 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public addProjectGroup(projectId: string, inlineObject5: InlineObject5, options?: any) {
        return UsersApiFp(this.configuration).addProjectGroup(projectId, inlineObject5, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add project user
     * @param {string} projectId Project ID
     * @param {InlineObject3} inlineObject3 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public addProjectUser(projectId: string, inlineObject3: InlineObject3, options?: any) {
        return UsersApiFp(this.configuration).addProjectUser(projectId, inlineObject3, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create organization group
     * @param {string} organizationId Organization ID
     * @param {UserGroup} userGroup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createOrganizationGroup(organizationId: string, userGroup: UserGroup, options?: any) {
        return UsersApiFp(this.configuration).createOrganizationGroup(organizationId, userGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete organization group
     * @param {string} organizationId Organization ID
     * @param {string} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteOrganizationGroup(organizationId: string, groupId: string, options?: any) {
        return UsersApiFp(this.configuration).deleteOrganizationGroup(organizationId, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(options?: any) {
        return UsersApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization groups
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listOrganizationGroups(organizationId: string, options?: any) {
        return UsersApiFp(this.configuration).listOrganizationGroups(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization invites
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listOrganizationInvites(organizationId: string, options?: any) {
        return UsersApiFp(this.configuration).listOrganizationInvites(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization users
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listOrganizationUsers(organizationId: string, options?: any) {
        return UsersApiFp(this.configuration).listOrganizationUsers(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List project groups
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listProjectGroups(projectId: string, options?: any) {
        return UsersApiFp(this.configuration).listProjectGroups(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List project invites
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listProjectInvites(projectId: string, options?: any) {
        return UsersApiFp(this.configuration).listProjectInvites(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List project users
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listProjectUsers(projectId: string, options?: any) {
        return UsersApiFp(this.configuration).listProjectUsers(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List user activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUserActivity(options?: any) {
        return UsersApiFp(this.configuration).listUserActivity(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove organization user
     * @param {string} organizationId Organization ID
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public removeOrganizationUser(organizationId: string, id: string, options?: any) {
        return UsersApiFp(this.configuration).removeOrganizationUser(organizationId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove project group
     * @param {string} projectId Project ID
     * @param {string} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public removeProjectGroup(projectId: string, groupId: string, options?: any) {
        return UsersApiFp(this.configuration).removeProjectGroup(projectId, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove project user
     * @param {string} projectId Project ID
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public removeProjectUser(projectId: string, id: string, options?: any) {
        return UsersApiFp(this.configuration).removeProjectUser(projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resend organization invite
     * @param {string} organizationId Organization ID
     * @param {string} id Invite ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public resendOrganizationInvite(organizationId: string, id: string, options?: any) {
        return UsersApiFp(this.configuration).resendOrganizationInvite(organizationId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resend project invite
     * @param {string} projectId Project ID
     * @param {string} id Invite ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public resendProjectInvite(projectId: string, id: string, options?: any) {
        return UsersApiFp(this.configuration).resendProjectInvite(projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke organization invite
     * @param {string} organizationId Organization ID
     * @param {string} id Invite ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public revokeOrganizationInvite(organizationId: string, id: string, options?: any) {
        return UsersApiFp(this.configuration).revokeOrganizationInvite(organizationId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke project invite
     * @param {string} projectId Project ID
     * @param {string} id Invite ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public revokeProjectInvite(projectId: string, id: string, options?: any) {
        return UsersApiFp(this.configuration).revokeProjectInvite(projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update organization group
     * @param {string} organizationId Organization ID
     * @param {string} groupId Group ID
     * @param {UserGroup} userGroup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateOrganizationGroup(organizationId: string, groupId: string, userGroup: UserGroup, options?: any) {
        return UsersApiFp(this.configuration).updateOrganizationGroup(organizationId, groupId, userGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update organization user
     * @param {string} organizationId Organization ID
     * @param {string} id User ID
     * @param {InlineObject19} inlineObject19 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateOrganizationUser(organizationId: string, id: string, inlineObject19: InlineObject19, options?: any) {
        return UsersApiFp(this.configuration).updateOrganizationUser(organizationId, id, inlineObject19, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update project group
     * @param {string} projectId Project ID
     * @param {string} groupId Group ID
     * @param {InlineObject6} inlineObject6 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateProjectGroup(projectId: string, groupId: string, inlineObject6: InlineObject6, options?: any) {
        return UsersApiFp(this.configuration).updateProjectGroup(projectId, groupId, inlineObject6, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update project user
     * @param {string} projectId Project ID
     * @param {string} id User ID
     * @param {InlineObject4} inlineObject4 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateProjectUser(projectId: string, id: string, inlineObject4: InlineObject4, options?: any) {
        return UsersApiFp(this.configuration).updateProjectUser(projectId, id, inlineObject4, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user password
     * @param {InlineObject2} inlineObject2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserPassword(inlineObject2: InlineObject2, options?: any) {
        return UsersApiFp(this.configuration).updateUserPassword(inlineObject2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user profile
     * @param {InlineObject1} inlineObject1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserProfile(inlineObject1: InlineObject1, options?: any) {
        return UsersApiFp(this.configuration).updateUserProfile(inlineObject1, options).then((request) => request(this.axios, this.basePath));
    }
}


